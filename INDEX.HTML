<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chayt - Secure Chat</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      /* Enhanced Color Palette */
      --bg-dark: #0a0e1a;
      --bg-card: #1a1f2e;
      --bg-elev: rgba(255,255,255,0.06);
      --accent: #00d4ff;
      --accent-2: #b794f6;
      --accent-hover: #00b8e6;
      --sent-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --received-bg: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --success: #00f5a0;
      --error: #ff6b6b;
      --warning: #ffd93d;
      --info: #74b9ff;
      --border-radius: 16px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --backdrop: saturate(180%) blur(20px);
      --sidebar-width: 320px;
      --header-height: 72px;
      --input-height: 96px;
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.15);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.2);
      --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --gradient-secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --gradient-accent: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: 
        radial-gradient(1200px 800px at 20% -10%, rgba(0, 212, 255, 0.15), transparent),
        radial-gradient(1000px 600px at 120% 10%, rgba(183, 148, 246, 0.15), transparent),
        radial-gradient(800px 400px at 50% 50%, rgba(116, 185, 255, 0.1), transparent),
        var(--bg-dark);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 0;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.2) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }

    /* Layout */
    .app-container {
      display: flex;
      height: 100vh;
      width: 100%;
    }

    /* Sidebar */
    .sidebar {
      width: var(--sidebar-width);
      background: rgba(26, 31, 46, 0.8);
      border-right: 1px solid rgba(255,255,255,0.08);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: var(--backdrop);
      box-shadow: var(--shadow-lg);
      position: relative;
    }

    .sidebar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, transparent 100%);
      pointer-events: none;
    }

    .friends-list {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .friend-item { padding: 10px 14px; border-radius: 10px; margin-bottom: 8px; cursor: pointer; display: flex; align-items: center; transition: var(--transition); position: relative; }
    .friend-item:hover { background: rgba(255,255,255,0.05); }

    .friend-item.active {
      background: rgba(99, 102, 241, 0.2);
    }

    .friend-item.hidden-chat {
      opacity: 0.5;
      background: rgba(255, 255, 255, 0.05);
    }

    .friend-avatar { width: 36px; height: 36px; border-radius: 12px; background: var(--bg-card); margin-right: 12px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; }

    .friend-name {
      flex: 1;
      font-size: 14px;
    }

    .friend-status {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .status-online {
      background: var(--success);
    }

    .status-offline {
      background: var(--text-secondary);
    }

    .status-away {
      background: var(--warning);
    }

    /* Main Content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Chat Area */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-header {
      padding: 14px 18px;
      background: rgba(18, 26, 43, 0.7);
      backdrop-filter: var(--backdrop);
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: var(--header-height);
    }

    .call-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 16px;
    }

    .call-controls button {
      padding: 8px 10px;
      font-size: 14px;
      background: rgba(99, 102, 241, 0.2);
      border-radius: 10px;
    }

    /* Extra UI polish */
    .tab-bar { display:flex; gap:8px; margin:8px 0; }
    .tab { padding:6px 10px; border-radius:8px; background: rgba(255,255,255,0.06); cursor:pointer; }
    .tab.active { background: rgba(99,102,241,0.35); }
    .emoji-grid { display:grid; grid-template-columns: repeat(8, 1fr); gap:6px; max-height:260px; overflow:auto; }
    .emoji-item { font-size:20px; cursor:pointer; text-align:center; padding:6px; border-radius:8px; }
    .emoji-item:hover { background: rgba(255,255,255,0.1); }
    .sticker-grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; max-height:260px; overflow:auto; }
    .link-card { background: rgba(255,255,255,0.06); padding:10px; border-radius:8px; margin-top:6px; }
    .friend-item.pinned::before { content:'\f08d'; font-family: 'Font Awesome 6 Free'; font-weight:900; color: var(--accent); margin-right:6px; }
    .economy { font-size:12px; color: var(--text-secondary); display:flex; gap:8px; justify-content:center; margin-top: 8px; }
    .badge { background: rgba(255,255,255,0.08); padding:4px 8px; border-radius:8px; font-size:11px; font-weight: 500; }
    .status-indicator { 
      position: absolute; 
      top: 8px; 
      right: 8px; 
      width: 8px; 
      height: 8px; 
      border-radius: 50%; 
      background: var(--success); 
      animation: pulse 2s infinite; 
    }
    .filters { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; align-items:center; }
    .filters label { font-size:12px; color: var(--text-secondary); }

    .chat-header h3 {
      font-size: 18px;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .chat-actions {
      display: flex;
      gap: 12px;
    }

    .chat-actions button {
      padding: 6px 12px;
      font-size: 12px;
      background: rgba(99, 102, 241, 0.2);
    }

    .chat-actions button:hover {
      background: rgba(99, 102, 241, 0.3);
    }

    /* Messages */
    #messages { 
      flex: 1; 
      overflow-y: auto; 
      padding: 28px; 
      display: flex; 
      flex-direction: column; 
      gap: 14px; 
      background: rgba(18, 26, 43, 0.3);
    }

    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 28px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .theme-default { background: rgba(18, 26, 43, 0.3); }
    .theme-dark { background: rgba(0, 0, 0, 0.5); }
    .theme-light { background: rgba(255, 255, 255, 0.1); }
    .theme-colorful { background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(167, 139, 250, 0.1)); }

    .message { 
      max-width: 72%; 
      padding: 16px 20px; 
      border-radius: var(--border-radius); 
      position: relative; 
      animation: messageSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
      line-height: 1.6; 
      word-wrap: break-word; 
      transition: var(--transition); 
      box-shadow: var(--shadow-md);
      backdrop-filter: blur(10px);
    }

    .message.sent { 
      background: var(--sent-bg); 
      align-self: flex-end; 
      border-bottom-right-radius: 8px; 
      color: white; 
      border: 1px solid rgba(255,255,255,0.1);
    }

    .message.received { 
      background: var(--received-bg); 
      align-self: flex-start; 
      border-bottom-left-radius: 8px; 
      border: 1px solid rgba(255,255,255,0.05);
    }

    @keyframes messageSlideIn {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .message .timestamp {
      font-size: 10px;
      opacity: 0.7;
      margin-top: 6px;
      text-align: right;
    }

    .message img {
      max-width: 100%;
      border-radius: 12px;
      margin-top: 8px;
      display: block;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .owner-badge {
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: bold;
      font-size: 0.8em;
      margin-left: 5px;
    }

    /* Input Area */
    .input-area { padding: 14px; background: rgba(18, 26, 43, 0.7); backdrop-filter: var(--backdrop); border-top: 1px solid rgba(255,255,255,0.06); display: flex; flex-direction: column; gap: 10px; position: relative; }

    .input-row {
      display: flex;
      gap: 12px;
    }

    .input-row textarea {
      flex: 1;
      padding: 14px 18px;
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 16px;
      transition: var(--transition);
      resize: none;
      min-height: 50px;
      max-height: 150px;
      font-family: 'Segoe UI', system-ui, sans-serif;
    }

    .input-row textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(34, 211, 238, 0.2);
    }

    .input-row textarea::placeholder {
      color: var(--text-secondary);
    }

    /* Image Preview */
    .image-preview {
      max-width: 100%;
      max-height: 200px;
      border-radius: 12px;
      margin-bottom: 12px;
      display: none;
    }

    .image-preview.visible {
      display: block;
    }

    .remove-image-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: var(--error);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .image-preview-container {
      position: relative;
      display: inline-block;
    }

    /* Auth Styles */
    #auth-container {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      background: var(--bg-card);
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      padding: 30px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      animation: fadeIn 0.5s ease;
    }

    .auth-header {
      text-align: center;
      margin-bottom: 10px;
    }

    .auth-header h2 {
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-size: 24px;
      margin-bottom: 8px;
    }

    .auth-header p {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .auth-tabs {
      display: flex;
      background: rgba(15, 23, 42, 0.5);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .auth-tab {
      flex: 1;
      padding: 12px;
      text-align: center;
      cursor: pointer;
      transition: var(--transition);
    }

    .auth-tab.active {
      background: var(--accent);
      font-weight: 600;
      color: #0b1020;
    }

    .auth-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .input-group label {
      font-size: 14px;
      color: var(--text-secondary);
    }

    input {
      padding: 14px 18px;
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 16px;
      transition: var(--transition);
    }

    input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }

    input::placeholder {
      color: var(--text-secondary);
    }

    button { 
      padding: 14px 20px; 
      background: var(--gradient-accent); 
      color: white; 
      border: none; 
      border-radius: var(--border-radius); 
      cursor: pointer; 
      font-weight: 600; 
      font-size: 15px; 
      transition: var(--transition); 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      gap: 10px; 
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    button:active {
      transform: translateY(-1px);
    }

    button:disabled {
      background: #4b5563;
      cursor: not-allowed;
      transform: none;
    }

    .status {
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      text-align: center;
      margin-top: 8px;
      transition: var(--transition);
    }

    .status.success {
      background: rgba(16, 185, 129, 0.15);
      color: var(--success);
    }

    .status.error {
      background: rgba(239, 68, 68, 0.15);
      color: var(--error);
    }

    .status.loading {
      background: rgba(99, 102, 241, 0.15);
      color: var(--accent);
    }

    /* File Input */
    .file-input-container {
      position: relative;
      flex: 1;
    }

    .file-input-container input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    .file-input-container .custom-file-input {
      padding: 14px 24px;
      background: rgba(15, 23, 42, 0.5);
      border: 1px dashed rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-weight: 500;
      transition: var(--transition);
    }

    .file-input-container:hover .custom-file-input {
      border-color: var(--accent);
      background: rgba(15, 23, 42, 0.7);
    }

    .input-controls { display: flex; justify-content: space-between; align-items: center; }
    .primary-controls { display: flex; gap: 8px; }
    .control-btn { padding: 8px; background: transparent; border: none; color: var(--text-secondary); border-radius: 8px; cursor: pointer; transition: var(--transition); }
    .control-btn:hover { background: rgba(255,255,255,0.1); color: var(--text-primary); }
    .dropdown-menu { position: absolute; bottom: 100%; right: 0; background: var(--bg-card); border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); padding: 8px; min-width: 180px; z-index: 1000; }
    .dropdown-item { display: flex; align-items: center; gap: 12px; padding: 10px 12px; border-radius: 8px; cursor: pointer; transition: var(--transition); }
    .dropdown-item:hover { background: rgba(255,255,255,0.1); }
    .dropdown-item i { width: 16px; }

    /* Password Visibility Toggle */
    .password-container {
      position: relative;
    }

    .toggle-password {
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      color: var(--text-secondary);
    }

    .password-input {
      padding-right: 35px !important;
    }

    /* Modals */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: var(--transition);
    }

    .modal.active {
      opacity: 1;
      pointer-events: all;
    }

    .modal-content {
      background: var(--bg-card);
      border-radius: var(--border-radius);
      padding: 24px;
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      transform: translateY(20px);
      transition: var(--transition);
    }

    .modal.active .modal-content {
      transform: translateY(0);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-header h3 {
      font-size: 20px;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
    }

    /* Friend Request Badge */
    .request-badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: var(--error);
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }

    /* Background Options */
    .bg-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 12px;
    }

    .bg-option {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      height: 80px;
      border: 2px solid transparent;
      transition: var(--transition);
    }

    .bg-option:hover {
      transform: translateY(-2px);
    }

    .bg-option.active {
      border-color: var(--accent);
    }

    .bg-option .bg-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      padding: 4px;
      text-align: center;
      font-size: 12px;
    }

    /* Friend Checkbox */
    .friend-checkbox {
      display: flex;
      align-items: center;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 4px;
      transition: var(--transition);
    }

    .friend-checkbox:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .friend-checkbox input {
      margin-right: 8px;
    }

    /* Request Item */
    .request-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 8px;
      background: rgba(255, 255, 255, 0.05);
    }

    .request-actions {
      display: flex;
      gap: 8px;
    }

    .request-actions button {
      padding: 6px 12px;
      font-size: 12px;
    }

    /* Add Friends to Group */
    .add-friends-container {
      margin-top: 16px;
    }

    /* User Profile */
    .user-profile {
      padding: 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    .profile-view {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .profile-avatar {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--bg-card);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
      position: relative;
      cursor: pointer;
    }

    .profile-avatar img {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      object-fit: cover;
    }

    .profile-name {
      font-size: 18px;
      font-weight: bold;
    }

    .profile-description {
      color: var(--text-secondary);
      font-size: 14px;
      text-align: center;
      margin-bottom: 12px;
    }

    .profile-edit-btn {
      width: 100%;
      margin-top: 12px;
    }

    .profile-edit-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Profile Preview in Messages */
    .message-user-profile {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      cursor: pointer;
    }

    .message-user-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--bg-card);
      margin-right: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
    }

    .message-user-avatar img {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      object-fit: cover;
    }

    .message-username {
      font-weight: bold;
    }

    /* Message Actions */
    .message-actions {
      position: absolute;
      top: -10px;
      right: -10px;
      display: none;
      background: var(--bg-card);
      border-radius: 20px;
      padding: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      z-index: 1;
    }

    .message:hover .message-actions {
      display: flex;
    }

    .message-action {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      margin: 0 2px;
      background: rgba(255, 255, 255, 0.1);
    }

    .message-action:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Reactions */
    .reactions {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    .reaction {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 2px 6px;
      font-size: 12px;
      cursor: pointer;
    }

    .reaction:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Pinned Messages */
    .pinned-messages {
      background: rgba(99, 102, 241, 0.1);
      border-left: 3px solid var(--accent);
      padding: 8px;
      margin-bottom: 16px;
      border-radius: 0 8px 8px 0;
    }

    .pinned-messages h4 {
      margin-bottom: 8px;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Search Bar */
    .search-bar { padding: 12px; background: rgba(18, 26, 43, 0.85); border-bottom: 1px solid rgba(255,255,255,0.06); }

    .search-bar input {
      width: 100%;
      padding: 8px 12px;
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text-primary);
    }

    /* Typing Indicator */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 12px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .typing-dot {
      width: 6px;
      height: 6px;
      background: var(--text-secondary);
      border-radius: 50%;
      animation: typingAnimation 1.4s infinite ease-in-out;
    }

    .typing-dot:nth-child(1) {
      animation-delay: 0s;
    }

    .typing-dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    /* Blocked Users */
    .blocked-user-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 8px;
      background: rgba(255, 255, 255, 0.05);
    }

    /* Context Menu */
    .context-menu {
      position: absolute;
      background: var(--bg-card);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
      min-width: 160px;
      overflow: hidden;
    }

    .context-menu-item {
      padding: 10px 16px;
      cursor: pointer;
      transition: var(--transition);
    }

    .context-menu-item:hover {
      background: rgba(99, 102, 241, 0.2);
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }

    @keyframes typingAnimation {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-4px); }
    }

    .loading {
      animation: pulse 1.5s infinite;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 4px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .sidebar {
        width: 80px;
      }
      
      .friend-name {
        display: none;
      }
      
      .friend-avatar {
        margin-right: 0;
      }
    }

    @media (max-width: 600px) {
      .btn-group {
        flex-direction: column;
      }
      
      .input-row {
        flex-direction: column;
      }
      
      .message {
        max-width: 90%;
      }
      
      .bg-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Animated Backgrounds */
    .animated-bg-1 {
      background: linear-gradient(-45deg, var(--accent), var(--accent-2), #38bdf8, #10b981);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
    }

    .animated-bg-2 {
      background: linear-gradient(-45deg, var(--accent-2), var(--accent), #f59e0b, #ef4444);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
    }

    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Notification Styles */
    .notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      max-width: 400px;
      pointer-events: none;
    }

    .notification {
      background: rgba(18, 26, 43, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transform: translateX(100%);
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: auto;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .notification.show {
      transform: translateX(0);
      opacity: 1;
    }

    .notification.hide {
      transform: translateX(100%);
      opacity: 0;
    }

    .notification-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .notification-title {
      font-weight: 600;
      font-size: 14px;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .notification-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: var(--transition);
    }

    .notification-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }

    .notification-body {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.4;
      margin-bottom: 8px;
    }

    .notification-meta {
      font-size: 11px;
      color: var(--text-secondary);
      opacity: 0.7;
    }

    .notification-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: white;
    }

    .notification-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: var(--accent);
      border-radius: 0 0 12px 12px;
      transition: width linear;
    }

    .notification.message .notification-icon {
      background: var(--accent);
    }

    .notification.friend-request .notification-icon {
      background: var(--success);
    }

    .notification.group-invite .notification-icon {
      background: var(--warning);
    }

    .notification.error .notification-icon {
      background: var(--error);
    }

    /* Notification Settings */
    .notification-settings {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
    }

    .notification-toggle {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: white;
      cursor: pointer;
      box-shadow: 0 4px 16px rgba(34, 211, 238, 0.3);
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .notification-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(34, 211, 238, 0.4);
    }

    .notification-toggle.disabled {
      background: var(--text-secondary);
      box-shadow: none;
    }

    .notification-toggle.disabled:hover {
      transform: none;
    }

    /* Mobile responsive */
    @media (max-width: 768px) {
      .notification-container {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
      }

      .notification {
        margin-bottom: 8px;
      }

      .notification-settings {
        bottom: 10px;
        right: 10px;
      }

      .notification-toggle {
        width: 48px;
        height: 48px;
        font-size: 18px;
      }
    }

    /* Enhanced Theme System */
    .theme-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
      margin-top: 8px;
    }

    .theme-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px;
      border-radius: var(--border-radius);
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid transparent;
      cursor: pointer;
      transition: var(--transition);
    }

    .theme-option:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .theme-option.active {
      border-color: var(--accent);
      background: rgba(0, 212, 255, 0.1);
    }

    .theme-preview {
      width: 60px;
      height: 40px;
      border-radius: 8px;
      margin-bottom: 8px;
      position: relative;
      overflow: hidden;
    }

    .theme-default-preview {
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1f2e 100%);
    }

    .theme-ocean-preview {
      background: linear-gradient(135deg, #0c4a6e 0%, #0284c7 50%, #0ea5e9 100%);
    }

    .theme-sunset-preview {
      background: linear-gradient(135deg, #dc2626 0%, #ea580c 50%, #f59e0b 100%);
    }

    .theme-forest-preview {
      background: linear-gradient(135deg, #166534 0%, #16a34a 50%, #22c55e 100%);
    }

    .theme-neon-preview {
      background: linear-gradient(135deg, #7c3aed 0%, #a855f7 50%, #ec4899 100%);
      box-shadow: 0 0 20px rgba(168, 85, 247, 0.5);
    }

    .theme-dark-preview {
      background: linear-gradient(135deg, #000000 0%, #1f2937 100%);
    }

    .theme-light-preview {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    }

    .theme-animated-preview {
      background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
      background-size: 400% 400%;
      animation: gradientShift 3s ease infinite;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Style Options */
    .style-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 8px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      padding: 8px;
      border-radius: 8px;
      transition: var(--transition);
    }

    .checkbox-label:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .checkbox-label input[type="checkbox"] {
      display: none;
    }

    .checkmark {
      width: 20px;
      height: 20px;
      border: 2px solid var(--text-secondary);
      border-radius: 4px;
      position: relative;
      transition: var(--transition);
    }

    .checkbox-label input[type="checkbox"]:checked + .checkmark {
      background: var(--accent);
      border-color: var(--accent);
    }

    .checkbox-label input[type="checkbox"]:checked + .checkmark::after {
      content: 'âœ“';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 12px;
      font-weight: bold;
    }

    /* Enhanced Animations */
    .fade-in {
      animation: fadeIn 0.5s ease-in;
    }

    .slide-up {
      animation: slideUp 0.4s ease-out;
    }

    .bounce-in {
      animation: bounceIn 0.6s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes bounceIn {
      0% {
        opacity: 0;
        transform: scale(0.3);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
      70% {
        transform: scale(0.9);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Enhanced Friend Items */
    .friend-item {
      position: relative;
      overflow: hidden;
    }

    .friend-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transition: left 0.6s;
    }

    .friend-item:hover::before {
      left: 100%;
    }

    /* Enhanced Modals */
    .modal {
      backdrop-filter: blur(8px);
    }

    .modal-content {
      background: rgba(26, 31, 46, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: var(--shadow-lg);
    }

    /* Enhanced Input Fields */
    input, textarea, select {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: var(--transition);
    }

    input:focus, textarea:focus, select:focus {
      background: rgba(255, 255, 255, 0.08);
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
    }

    /* Compact Mode */
    .compact-mode .message {
      padding: 8px 12px;
      max-width: 85%;
    }

    .compact-mode .friend-item {
      padding: 6px 10px;
    }

    .compact-mode .sidebar {
      width: 280px;
    }

    .compact-mode .chat-header {
      height: 50px;
    }

    .compact-mode .input-area {
      height: 60px;
    }

    /* Enhanced Game Styles */
    .game-message {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--border-radius);
      padding: 16px;
      margin: 8px 0;
      transition: var(--transition);
    }

    .game-message:hover {
      background: rgba(255, 255, 255, 0.08);
      transform: translateY(-2px);
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .game-status {
      font-size: 12px;
      opacity: 0.8;
      background: rgba(255, 255, 255, 0.1);
      padding: 4px 8px;
      border-radius: 12px;
    }

    .game-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .join-game-btn, .start-game-btn, .view-game-btn {
      padding: 6px 12px;
      font-size: 12px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
    }

    .join-game-btn {
      background: var(--accent);
      color: white;
    }

    .start-game-btn {
      background: var(--success);
      color: white;
    }

    .view-game-btn {
      background: var(--info);
      color: white;
    }

    .join-game-btn:hover, .start-game-btn:hover, .view-game-btn:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }

    /* Loading States */
    .loading {
      position: relative;
      overflow: hidden;
    }

    .loading::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      animation: loading 1.5s infinite;
    }

    @keyframes loading {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    /* Enhanced Scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Status Messages */
    .status {
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      margin-top: 8px;
      transition: var(--transition);
    }

    .status.success {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
      border: 1px solid rgba(16, 185, 129, 0.3);
    }

    .status.error {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error);
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .status.info {
      background: rgba(56, 189, 248, 0.2);
      color: var(--info);
      border: 1px solid rgba(56, 189, 248, 0.3);
    }

    .status.loading {
      background: rgba(245, 158, 11, 0.2);
      color: var(--warning);
      border: 1px solid rgba(245, 158, 11, 0.3);
    }

    /* Patch Notes Styling */
    .patchnotes-container {
      max-height: 70vh;
      overflow-y: auto;
      padding: 20px;
    }

    .version-header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: var(--gradient-accent);
      border-radius: var(--border-radius);
      color: white;
    }

    .version-header h3 {
      margin: 0 0 8px 0;
      font-size: 24px;
      font-weight: 700;
    }

    .version-date {
      font-size: 14px;
      opacity: 0.9;
    }

    .update-section {
      margin-bottom: 25px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: var(--border-radius);
      border: 1px solid rgba(255, 255, 255, 0.08);
      transition: var(--transition);
    }

    .update-section:hover {
      background: rgba(255, 255, 255, 0.05);
      transform: translateY(-2px);
    }

    .update-section h4 {
      margin: 0 0 15px 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .update-section ul {
      margin: 0;
      padding-left: 20px;
      list-style: none;
    }

    .update-section li {
      margin-bottom: 8px;
      padding: 6px 0;
      font-size: 14px;
      line-height: 1.5;
      position: relative;
      transition: var(--transition);
    }

    .update-section li:hover {
      color: var(--accent);
      transform: translateX(5px);
    }

    .update-section li::before {
      content: '';
      position: absolute;
      left: -15px;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 4px;
      background: var(--accent);
      border-radius: 50%;
    }

    .version-footer {
      text-align: center;
      margin-top: 30px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: var(--border-radius);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .version-footer p {
      margin: 5px 0;
      font-size: 14px;
      opacity: 0.8;
    }

    .version-footer p:first-child {
      font-weight: 600;
      color: var(--accent);
    }

    /* Patch Notes Scrollbar */
    .patchnotes-container::-webkit-scrollbar {
      width: 6px;
    }

    .patchnotes-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }

    .patchnotes-container::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 3px;
    }

    .patchnotes-container::-webkit-scrollbar-thumb:hover {
      background: var(--accent-hover);
    }
  </style>
</head>
<body>
  <!-- Notification Container -->
  <div class="notification-container" id="notification-container"></div>
  
  <!-- Notification Settings -->
  <div class="notification-settings">
    <button class="notification-toggle" id="notification-toggle" title="Toggle Notifications">
      <i class="fas fa-bell"></i>
    </button>
    <button class="notification-toggle" id="test-notification" title="Test Notification" style="margin-left: 8px; background: var(--success);">
      <i class="fas fa-test-tube"></i>
    </button>
  </div>

  <!-- Auth Container -->
  <div id="auth-container">
    <div class="auth-header">
      <h2>Welcome to Chayt</h2>
      <p>Secure real-time messaging</p>
    </div>

    <div class="auth-tabs">
      <div class="auth-tab active" id="login-tab">Sign In</div>
      <div class="auth-tab" id="register-tab">Sign Up</div>
    </div>

    <div class="auth-form" id="login-form">
      <div class="input-group">
        <label for="login-username">Username</label>
        <input type="text" id="login-username" placeholder="Enter your username">
      </div>

      <div class="input-group">
        <label for="login-password">Password</label>
        <div class="password-container">
          <input type="password" id="login-password" class="password-input" placeholder="Enter your password">
          <i class="fas fa-eye toggle-password" id="toggle-login-password"></i>
        </div>
      </div>

      <button id="login-btn">
        <i class="fas fa-sign-in-alt"></i>
        <span>Sign In</span>
      </button>

      <div id="login-status" class="status"></div>
    </div>

    <div class="auth-form" id="register-form" style="display: none;">
      <div class="input-group">
        <label for="register-username">Username</label>
        <input type="text" id="register-username" placeholder="Choose a username">
      </div>

      <div class="input-group">
        <label for="register-password">Password</label>
        <div class="password-container">
          <input type="password" id="register-password" class="password-input" placeholder="Create a password">
          <i class="fas fa-eye toggle-password" id="toggle-register-password"></i>
        </div>
      </div>

      <div class="input-group">
        <label for="confirm-password">Confirm Password</label>
        <div class="password-container">
          <input type="password" id="confirm-password" class="password-input" placeholder="Confirm your password">
          <i class="fas fa-eye toggle-password" id="toggle-confirm-password"></i>
        </div>
      </div>

      <button id="register-btn">
        <i class="fas fa-user-plus"></i>
        <span>Create Account</span>
      </button>

      <div id="register-status" class="status"></div>
    </div>
  </div>

  <!-- Main App Container -->
  <div class="app-container" id="app-container" style="display: none;">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="search-bar">
        <input type="text" id="chat-search" placeholder="Search chats...">
        <div class="economy">
          <span id="coins" class="badge">Coins: 0</span>
          <span id="streak" class="badge">Streak: 0</span>
          <span id="level" class="badge">Level: 1</span>
        </div>
      </div>
      <div class="friends-list" id="friends-list">
        <div class="friend-item" id="add-friend-btn">
          <div class="friend-avatar"><i class="fas fa-user-plus"></i></div>
          <div class="friend-name">Add Friend</div>
        </div>
        <div class="friend-item" id="friend-requests-btn">
          <div class="friend-avatar"><i class="fas fa-user-clock"></i></div>
          <div class="friend-name">Friend Requests</div>
          <div id="request-badge" class="request-badge" style="display: none;"></div>
        </div>
        <div class="friend-item" id="create-group-btn">
          <div class="friend-avatar"><i class="fas fa-users"></i></div>
          <div class="friend-name">Create Group</div>
        </div>
        <div class="friend-item" id="status-updates-btn">
          <div class="friend-avatar"><i class="fas fa-bullhorn"></i></div>
          <div class="friend-name">Status Updates</div>
        </div>
        <div class="friend-item" id="notes-btn">
          <div class="friend-avatar"><i class="fas fa-sticky-note"></i></div>
          <div class="friend-name">Notes</div>
        </div>
        <!-- Friends and groups will be added here dynamically -->
      </div>
      
      <!-- User Profile -->
      <div class="user-profile">
        <div class="profile-view" id="profile-view">
          <div class="profile-avatar" id="profile-avatar">
            <span id="profile-avatar-text">U</span>
            <img id="profile-avatar-img" style="display: none;">
          </div>
          <div class="profile-name" id="profile-name">User</div>
          <div class="profile-description" id="profile-description">No description yet</div>
          <button class="profile-edit-btn" id="profile-edit-btn">
            <i class="fas fa-edit"></i>
            <span>Edit Profile</span>
          </button>
        </div>
        <div class="profile-edit-form" id="profile-edit-form" style="display: none;">
          <div class="input-group">
            <label>Profile Picture</label>
            <div class="file-input-container">
              <input type="file" id="profile-picture-upload" accept="image/*">
              <div class="custom-file-input">
                <i class="fas fa-image"></i>
                <span>Choose Image</span>
              </div>
            </div>
          </div>
          <div class="input-group">
            <label for="profile-description-input">Description</label>
            <textarea id="profile-description-input" placeholder="Tell us about yourself"></textarea>
          </div>
          <button id="save-profile-btn">
            <i class="fas fa-save"></i>
            <span>Save Profile</span>
          </button>
          <button id="cancel-profile-edit-btn" style="background: var(--bg-card);">
            <i class="fas fa-times"></i>
            <span>Cancel</span>
          </button>
        </div>
        <button class="logout-btn" id="logout-btn" style="width: 100%; margin-top: 12px;">
          <i class="fas fa-sign-out-alt"></i>
          <span>Logout</span>
        </button>
        <button class="settings-btn" id="settings-btn" style="width: 100%; margin-top: 12px;">
          <i class="fas fa-cog"></i>
          <span>Settings</span>
        </button>
        <button class="patchnotes-btn" id="patchnotes-btn" style="width: 100%; margin-top: 8px; background: var(--gradient-accent);">
          <i class="fas fa-rocket"></i>
          <span>What's New</span>
        </button>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Chat Area -->
      <div class="chat-area">
        <div class="chat-header">
          <h3 id="chat-title">Direct Messages</h3>
          <div class="call-controls">
            <button id="voice-call-btn" title="Voice Call"><i class="fas fa-phone"></i></button>
            <button id="video-call-btn" title="Video Call"><i class="fas fa-video"></i></button>
            <button id="screen-share-btn" title="Share Screen" style="display:none;"><i class="fas fa-desktop"></i></button>
            <button id="ptt-toggle-btn" title="Push-To-Talk (hold Space)" data-active="false"><i class="fas fa-microphone-slash"></i></button>
            <button id="group-voice-btn" title="Group Voice" style="display:none;"><i class="fas fa-headset"></i></button>
            <button id="chat-theme-btn" title="Chat Theme"><i class="fas fa-palette"></i></button>
            <button id="message-search-btn" title="Search Messages"><i class="fas fa-search"></i></button>
            <button id="music-share-btn" title="Share Music"><i class="fas fa-music"></i></button>
            <button id="test-message-btn" title="Test Message" onclick="addTestMessage()"><i class="fas fa-bug"></i></button>
          </div>
          <div class="chat-actions" id="chat-actions" style="display: none;">
            <button id="add-friends-to-group-btn"><i class="fas fa-user-plus"></i> Add Friends</button>
            <button id="leave-group-btn"><i class="fas fa-sign-out-alt"></i> Leave</button>
            <button id="kick-member-btn"><i class="fas fa-user-minus"></i> Kick</button>
          </div>
        </div>

        <div id="pinned-messages-container" style="display: none;">
          <div class="pinned-messages">
            <h4><i class="fas fa-thumbtack"></i> Pinned Messages</h4>
            <div id="pinned-messages"></div>
          </div>
        </div>

        <div id="messages"></div>
        
        <div class="typing-indicator" id="typing-indicator" style="display: none;">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <span id="typing-text"></span>
        </div>
        
        <div class="input-area">
          <div class="image-preview-container">
            <img id="image-preview" class="image-preview" src="" alt="Image preview">
            <button id="remove-image-btn" class="remove-image-btn" style="display: none;">Ã—</button>
          </div>
          <div class="filters">
            <label for="photo-filter-select">Filter:</label>
            <select id="photo-filter-select">
              <option value="none">None</option>
              <option value="grayscale(1)">Grayscale</option>
              <option value="sepia(1)">Sepia</option>
              <option value="blur(2px)">Blur</option>
              <option value="contrast(1.5)">Contrast</option>
              <option value="brightness(1.2)">Brightness</option>
              <option value="saturate(1.5)">Saturate</option>
              <option value="hue-rotate(90deg)">Hue Rotate</option>
            </select>
          </div>
          <div class="input-row">
            <textarea id="message" placeholder="Type your message..." autocomplete="off" rows="1"></textarea>
            <button id="send-text-btn">
              <i class="fas fa-paper-plane"></i>
            </button>
          </div>
          
          <div class="btn-group">
          <div class="input-controls">
            <div class="primary-controls">
              <button id="emoji-gif-btn" class="control-btn" title="Emoji & GIF">
                <i class="far fa-laugh"></i>
              </button>
              <button id="attach-btn" class="control-btn" title="Attach">
                <i class="fas fa-paperclip"></i>
              </button>
              <button id="record-voice-btn" class="control-btn" title="Voice Message">
                <i class="fas fa-microphone"></i>
              </button>
            </div>
            <div class="secondary-controls">
              <button id="more-options-btn" class="control-btn" title="More">
                <i class="fas fa-ellipsis-h"></i>
              </button>
            </div>
          </div>
          
          <!-- Hidden file inputs -->
          <input type="file" id="upload" accept="image/*" style="display:none;">
          <input type="file" id="file-upload" style="display:none;">
          
          <!-- Hidden elements for additional features -->
          <select id="ttl-select" style="display:none;">
            <option value="0">No expiry</option>
            <option value="300000">5 minutes</option>
            <option value="600000">10 minutes</option>
            <option value="3600000">1 hour</option>
          </select>
          <input type="datetime-local" id="schedule-time" style="display:none;">
          <button id="schedule-send-btn" style="display:none;">Schedule</button>
          <button id="send-image-btn" style="display:none;">Send Image</button>
          
          <!-- More options dropdown -->
          <div id="more-options-dropdown" class="dropdown-menu" style="display:none;">
            <div class="dropdown-item" data-action="image">
              <i class="fas fa-image"></i>
              <span>Image</span>
            </div>
            <div class="dropdown-item" data-action="file">
              <i class="fas fa-file"></i>
              <span>File</span>
            </div>
            <div class="dropdown-item" data-action="schedule">
              <i class="fas fa-clock"></i>
              <span>Schedule</span>
            </div>
            <div class="dropdown-item" data-action="ttl">
              <i class="fas fa-hourglass-half"></i>
              <span>Disappearing</span>
            </div>
            <div class="dropdown-item" data-action="games">
              <i class="fas fa-gamepad"></i>
              <span>Games</span>
            </div>
            <div class="dropdown-item" data-action="polls">
              <i class="fas fa-poll"></i>
              <span>Poll</span>
            </div>
            <div class="dropdown-item" data-action="draw">
              <i class="fas fa-pen"></i>
              <span>Draw</span>
            </div>
            <div class="dropdown-item" data-action="whiteboard">
              <i class="fas fa-chalkboard"></i>
              <span>Whiteboard</span>
            </div>

          </div>
          
          <div id="chat-status" class="status"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add Friend Modal -->
  <div class="modal" id="add-friend-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Add Friend</h3>
        <button class="modal-close" id="close-add-friend">&times;</button>
      </div>
      <div class="input-group">
        <label for="friend-username">Username</label>
        <input type="text" id="friend-username" placeholder="Enter friend's username">
      </div>
      <button id="send-request-btn" style="margin-top: 16px;">
        <i class="fas fa-user-plus"></i>
        <span>Send Request</span>
      </button>
      <div id="friend-status" class="status"></div>
    </div>
  </div>

  <!-- Call Modal -->
  <div class="modal" id="call-modal">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h3 id="call-modal-title">Call</h3>
        <button class="modal-close" id="close-call-modal">&times;</button>
      </div>
      <div id="call-container" style="display:flex; gap: 12px; align-items: stretch;">
        <video id="local-video" autoplay playsinline muted style="width: 240px; background:#000; border-radius: 8px;"></video>
        <video id="remote-video" autoplay playsinline style="flex:1; background:#000; border-radius: 8px;"></video>
      </div>
      <div style="display:flex; gap:8px; margin-top:12px;">
        <button id="toggle-mic-btn"><i class="fas fa-microphone"></i> Mic</button>
        <button id="toggle-cam-btn"><i class="fas fa-video"></i> Cam</button>
        <button id="toggle-screen-btn"><i class="fas fa-desktop"></i> Screen</button>
        <button id="end-call-btn" style="background: var(--error);"><i class="fas fa-phone-slash"></i> End</button>
      </div>
      <div id="call-status" class="status" style="margin-top:12px;"></div>
    </div>
  </div>

  <!-- Emoji/GIF Modal -->
  <div class="modal" id="emoji-gif-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Emoji & GIF</h3>
        <button class="modal-close" id="close-emoji-gif">&times;</button>
      </div>
      <div class="tab-bar">
        <div class="tab active" id="tab-emoji">Emoji</div>
        <div class="tab" id="tab-gif">GIF</div>
      </div>
      <div id="emoji-section">
        <div class="emoji-grid" id="emoji-grid"></div>
      </div>
      <div id="gif-section" style="display:none;">
        <div class="input-group">
        <input id="gif-search" placeholder="Search GIFs (GIPHY)">
        <button id="gif-search-btn"><i class="fas fa-search"></i> Search</button>
        </div>
        <div id="gif-results" style="display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; margin-top:12px;"></div>
      </div>
    </div>
  </div>

  <!-- Stickers Modal -->
  <div class="modal" id="stickers-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Stickers</h3>
        <button class="modal-close" id="close-stickers">&times;</button>
      </div>
      <div class="sticker-grid" id="sticker-grid"></div>
    </div>
  </div>

  <!-- Games Modal -->
  <div class="modal" id="games-modal">
    <div class="modal-content" style="max-width: 700px;">
      <div class="modal-header">
        <h3>Games</h3>
        <button class="modal-close" id="close-games">&times;</button>
      </div>
      <div style="display:flex; gap:8px; flex-wrap: wrap;">
        <button class="game-launch" data-game="tictactoe">Tic Tac Toe</button>
        <button class="game-launch" data-game="chess">Chess</button>
        <button class="game-launch" data-game="hangman">Hangman</button>
        <button class="game-launch" data-game="trivia">Trivia</button>
        <button class="game-launch" data-game="casino">Mini Casino</button>
        <button class="game-launch" data-game="uno">UNO</button>
      </div>
      <div id="game-container" style="margin-top:12px;"></div>
    </div>
  </div>

  <!-- Music Share Modal -->
  <div class="modal" id="music-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Share Music</h3>
        <button class="modal-close" id="close-music">&times;</button>
      </div>
      <div class="input-group">
        <input id="music-url" placeholder="Paste Spotify/YouTube link">
      </div>
      <button id="share-music-btn"><i class="fas fa-music"></i> Share</button>
    </div>
  </div>

  <!-- Status Updates Modal -->
  <div class="modal" id="status-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Status Updates</h3>
        <button class="modal-close" id="close-status">&times;</button>
      </div>
      <div class="input-group">
        <textarea id="status-text" placeholder="Whatâ€™s on your mind?" rows="3"></textarea>
      </div>
      <button id="post-status-btn"><i class="fas fa-bullhorn"></i> Post</button>
      <div id="status-feed" style="margin-top:12px;"></div>
    </div>
  </div>

  <!-- Search Modal -->
  <div class="modal" id="search-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Search Messages</h3>
        <button class="modal-close" id="close-search">&times;</button>
      </div>
      <div class="input-group">
        <input id="search-query" placeholder="Type to search messages">
      </div>
      <div id="search-results" style="max-height: 400px; overflow:auto; margin-top:8px;"></div>
    </div>
  </div>


  <!-- Report Modal -->
  <div class="modal" id="report-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Report Content</h3>
        <button class="modal-close" id="close-report">&times;</button>
      </div>
      <div class="input-group">
        <label>Reason</label>
        <input id="report-reason" placeholder="Describe the issue">
      </div>
      <button id="submit-report-btn" style="background: var(--error);"><i class="fas fa-flag"></i> Submit</button>
      <div id="report-status" class="status" style="margin-top:8px;"></div>
    </div>
  </div>

  <!-- Polls Modal -->
  <div class="modal" id="polls-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Create Poll</h3>
        <button class="modal-close" id="close-polls">&times;</button>
      </div>
      <div class="input-group">
        <label>Question</label>
        <input id="poll-question" placeholder="Your question">
      </div>
      <div class="input-group">
        <label>Options</label>
        <input class="poll-option" placeholder="Option 1">
        <input class="poll-option" placeholder="Option 2">
        <button id="add-poll-option">Add Option</button>
      </div>
      <button id="create-poll-btn"><i class="fas fa-poll"></i> Create</button>
    </div>
  </div>

  <!-- Drawing Modal -->
  <div class="modal" id="draw-modal">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h3>Drawing</h3>
        <button class="modal-close" id="close-draw">&times;</button>
      </div>
      <canvas id="draw-canvas" width="760" height="420" style="background:#111; border-radius:8px;"></canvas>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <input type="color" id="draw-color" value="#ffffff">
        <input type="range" id="draw-size" min="1" max="20" value="4">
        <button id="draw-clear">Clear</button>
        <button id="draw-send"><i class="fas fa-paper-plane"></i> Send</button>
      </div>
    </div>
  </div>

  <!-- Whiteboard Modal -->
  <div class="modal" id="whiteboard-modal">
    <div class="modal-content" style="max-width: 1000px;">
      <div class="modal-header">
        <h3>Collaborative Whiteboard</h3>
        <button class="modal-close" id="close-whiteboard">&times;</button>
      </div>
      <canvas id="whiteboard-canvas" width="940" height="520" style="background:#111; border-radius:8px;"></canvas>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <input type="color" id="whiteboard-color" value="#00eaff">
        <input type="range" id="whiteboard-size" min="1" max="20" value="3">
        <button id="whiteboard-clear">Clear</button>
      </div>
    </div>
  </div>



  <!-- Friend Requests Modal -->
  <div class="modal" id="requests-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Friend Requests</h3>
        <button class="modal-close" id="close-requests">&times;</button>
      </div>
      <div id="requests-list">
        <!-- Requests will be added here dynamically -->
      </div>
      <div id="requests-status" class="status"></div>
    </div>
  </div>

  <!-- Create Group Modal -->
  <div class="modal" id="create-group-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Create Group Chat</h3>
        <button class="modal-close" id="close-create-group">&times;</button>
      </div>
      <div class="input-group">
        <label for="group-name">Group Name</label>
        <input type="text" id="group-name" placeholder="Enter group name">
      </div>
      <div class="input-group">
        <label>Add Members</label>
        <div id="friends-to-add">
          <!-- Friends will be listed here for selection -->
        </div>
      </div>
      <button id="create-group-confirm-btn" style="margin-top: 16px;">
        <i class="fas fa-users"></i>
        <span>Create Group</span>
      </button>
      <div id="group-status" class="status"></div>
    </div>
  </div>

  <!-- Add Friends to Group Modal -->
  <div class="modal" id="add-friends-to-group-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Add Friends to Group</h3>
        <button class="modal-close" id="close-add-friends-to-group">&times;</button>
      </div>
      <div class="input-group">
        <div id="friends-to-add-to-group">
          <!-- Friends will be listed here for selection -->
        </div>
      </div>
      <button id="add-friends-to-group-confirm-btn" style="margin-top: 16px;">
        <i class="fas fa-user-plus"></i>
        <span>Add Friends</span>
      </button>
      <div id="add-friends-status" class="status"></div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settings-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Settings</h3>
        <button class="modal-close" id="close-settings">&times;</button>
      </div>
      
      <div class="auth-tabs">
        <div class="auth-tab active" id="appearance-tab">Appearance</div>
        <div class="auth-tab" id="blocked-users-tab">Blocked Users</div>
        <div class="auth-tab" id="security-tab">Security</div>
        <div class="auth-tab" id="patchnotes-tab">Patch Notes</div>
      </div>
      
      <div id="appearance-settings">
        <div class="input-group">
          <label>Theme</label>
          <div class="theme-grid">
            <div class="theme-option active" data-theme="default">
              <div class="theme-preview theme-default-preview"></div>
              <span>Default</span>
            </div>
            <div class="theme-option" data-theme="ocean">
              <div class="theme-preview theme-ocean-preview"></div>
              <span>Ocean</span>
            </div>
            <div class="theme-option" data-theme="sunset">
              <div class="theme-preview theme-sunset-preview"></div>
              <span>Sunset</span>
            </div>
            <div class="theme-option" data-theme="forest">
              <div class="theme-preview theme-forest-preview"></div>
              <span>Forest</span>
            </div>
            <div class="theme-option" data-theme="neon">
              <div class="theme-preview theme-neon-preview"></div>
              <span>Neon</span>
            </div>
            <div class="theme-option" data-theme="dark">
              <div class="theme-preview theme-dark-preview"></div>
              <span>Dark</span>
            </div>
            <div class="theme-option" data-theme="light">
              <div class="theme-preview theme-light-preview"></div>
              <span>Light</span>
            </div>
            <div class="theme-option" data-theme="animated">
              <div class="theme-preview theme-animated-preview"></div>
              <span>Animated</span>
            </div>
          </div>
        </div>
        
        <div class="input-group">
          <label>Message Style</label>
          <div class="style-options">
            <label class="checkbox-label">
              <input type="checkbox" id="message-animations" checked>
              <span class="checkmark"></span>
              Enable message animations
            </label>
            <label class="checkbox-label">
              <input type="checkbox" id="sound-effects" checked>
              <span class="checkmark"></span>
              Enable sound effects
            </label>
            <label class="checkbox-label">
              <input type="checkbox" id="typing-indicator" checked>
              <span class="checkmark"></span>
              Show typing indicators
            </label>
          </div>
        </div>

        <div class="input-group">
          <label>Interface</label>
          <div class="style-options">
            <label class="checkbox-label">
              <input type="checkbox" id="compact-mode">
              <span class="checkmark"></span>
              Compact mode
            </label>
            <label class="checkbox-label">
              <input type="checkbox" id="show-timestamps" checked>
              <span class="checkmark"></span>
              Show message timestamps
            </label>
            <label class="checkbox-label">
              <input type="checkbox" id="auto-scroll" checked>
              <span class="checkmark"></span>
              Auto-scroll to new messages
            </label>
          </div>
        </div>

        <button id="save-settings-btn" style="margin-top: 16px;">
          <i class="fas fa-save"></i>
          <span>Save Settings</span>
        </button>
        <div id="settings-status" class="status"></div>
      </div>
      
      <div id="blocked-users-settings" style="display: none;">
        <div id="blocked-users-list">
          <!-- Blocked users will be listed here -->
        </div>
        <div id="blocked-users-status" class="status"></div>
      </div>

      <div id="security-settings" style="display:none;">
        <div class="input-group">
          <label>End-to-End Encryption (optional)</label>
          <input id="e2ee-passphrase" type="password" placeholder="Set a passphrase to encrypt messages">
        </div>
        <div class="input-group">
          <label>Two-Factor (coming soon)</label>
          <input disabled placeholder="Email/SMS OTP planned" />
        </div>
        <button id="save-security-btn"><i class="fas fa-shield"></i> Save Security</button>
        <div id="security-status" class="status"></div>
      </div>

      <div id="patchnotes-settings" style="display:none;">
        <div class="patchnotes-container">
          <div class="version-header">
            <h3>ðŸš€ Version 2.0 - Major Update</h3>
            <span class="version-date">December 2024</span>
          </div>
          
          <div class="update-section">
            <h4>ðŸŽ¨ UI & Design Overhaul</h4>
            <ul>
              <li>âœ¨ Complete visual redesign with modern aesthetics</li>
              <li>ðŸŒˆ 8 beautiful new themes (Ocean, Sunset, Forest, Neon, etc.)</li>
              <li>ðŸ’« Smooth animations and micro-interactions throughout</li>
              <li>ðŸŽ­ Glassmorphism effects and enhanced shadows</li>
              <li>ðŸ“± Improved mobile responsiveness</li>
              <li>ðŸŽ¯ Better typography and spacing</li>
            </ul>
          </div>

          <div class="update-section">
            <h4>ðŸ”” Advanced Notification System</h4>
            <ul>
              <li>ðŸ”” Smart in-app notifications when active</li>
              <li>ðŸ“± Browser push notifications when away</li>
              <li>ðŸ”Š Notification sounds with Web Audio API</li>
              <li>ðŸ‘¥ Friend request notifications</li>
              <li>ðŸ’¬ Mention notifications (@username)</li>
              <li>âš™ï¸ Toggle notifications on/off</li>
              <li>ðŸ§ª Test notification feature</li>
            </ul>
          </div>

          <div class="update-section">
            <h4>ðŸŽ® Fixed Multiplayer Games</h4>
            <ul>
              <li>ðŸŽ¯ Tic Tac Toe now works with 2+ players</li>
              <li>ðŸƒ UNO game with proper deck generation</li>
              <li>ðŸ‘¥ Join game functionality</li>
              <li>â–¶ï¸ Start game when players are ready</li>
              <li>ðŸ”„ Real-time game state updates</li>
              <li>ðŸŽ¨ Enhanced game UI with action buttons</li>
            </ul>
          </div>

          <div class="update-section">
            <h4>âš™ï¸ Enhanced Settings</h4>
            <ul>
              <li>ðŸŽ¨ Comprehensive theme system</li>
              <li>ðŸ”§ Message style customization</li>
              <li>ðŸ“± Interface options (compact mode, timestamps)</li>
              <li>ðŸ’¾ Persistent settings storage</li>
              <li>ðŸ”„ Real-time settings preview</li>
              <li>âœ… Custom styled checkboxes</li>
            </ul>
          </div>

          <div class="update-section">
            <h4>ðŸš€ Performance & Technical</h4>
            <ul>
              <li>âš¡ Optimized animations and transitions</li>
              <li>ðŸ’¾ Enhanced localStorage management</li>
              <li>ðŸ”§ Better event handling</li>
              <li>ðŸ“¦ Improved code organization</li>
              <li>ðŸŽ¯ CSS custom properties for theming</li>
              <li>ðŸ“± Service worker for offline support</li>
            </ul>
          </div>

          <div class="update-section">
            <h4>ðŸŽ‰ New Features</h4>
            <ul>
              <li>ðŸŽ¨ Theme preview system</li>
              <li>ðŸ”” Notification toggle button</li>
              <li>ðŸ§ª Test notification feature</li>
              <li>ðŸ“± Compact mode for smaller screens</li>
              <li>ðŸŽ­ Enhanced loading states</li>
              <li>ðŸ“œ Custom scrollbars</li>
            </ul>
          </div>

          <div class="update-section">
            <h4>ðŸ› Bug Fixes</h4>
            <ul>
              <li>ðŸ”§ Fixed AI functionality removal</li>
              <li>ðŸŽ® Fixed minigame multiplayer issues</li>
              <li>ðŸ’¾ Fixed settings persistence</li>
              <li>ðŸŽ¨ Fixed theme switching</li>
              <li>ðŸ“± Fixed mobile responsiveness</li>
              <li>ðŸ”” Fixed notification system</li>
            </ul>
          </div>

          <div class="update-section">
            <h4>ðŸ”® Coming Soon</h4>
            <ul>
              <li>ðŸ” Two-factor authentication</li>
              <li>ðŸŽµ Voice message improvements</li>
              <li>ðŸ“ File sharing enhancements</li>
              <li>ðŸŒ Multi-language support</li>
              <li>ðŸ“Š Usage analytics</li>
              <li>ðŸŽ¨ More theme options</li>
            </ul>
          </div>

          <div class="version-footer">
            <p>Thank you for using Chayt! ðŸŽ‰</p>
            <p>Your feedback helps us improve. Keep chatting! ðŸ’¬</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Profile View Modal -->
  <div class="modal" id="profile-view-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="profile-modal-title">User Profile</h3>
        <button class="modal-close" id="close-profile-view">&times;</button>
      </div>
      <div class="profile-view" id="profile-modal-view">
        <div class="profile-avatar" id="profile-modal-avatar">
          <span id="profile-modal-avatar-text">U</span>
          <img id="profile-modal-avatar-img" style="display: none;">
        </div>
        <div class="profile-name" id="profile-modal-name">User</div>
        <div class="profile-description" id="profile-modal-description">No description yet</div>
        <button id="block-user-btn" style="width: 100%; margin-top: 12px; background: var(--error);">
          <i class="fas fa-ban"></i>
          <span>Block User</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Reaction Picker Modal -->
  <div class="modal" id="reaction-picker-modal">
    <div class="modal-content" style="width: auto; padding: 12px;">
      <div class="modal-header">
        <h3>Add Reaction</h3>
        <button class="modal-close" id="close-reaction-picker">&times;</button>
      </div>
      <div style="display: flex; gap: 8px;">
        <div class="reaction-option" data-reaction="â¤ï¸">â¤ï¸</div>
        <div class="reaction-option" data-reaction="ðŸ˜‚">ðŸ˜‚</div>
        <div class="reaction-option" data-reaction="ðŸ˜®">ðŸ˜®</div>
        <div class="reaction-option" data-reaction="ðŸ˜¢">ðŸ˜¢</div>
        <div class="reaction-option" data-reaction="ðŸ‘">ðŸ‘</div>
        <div class="reaction-option" data-reaction="ðŸ‘Ž">ðŸ‘Ž</div>
        <div class="reaction-option" data-reaction="ðŸ”¥">ðŸ”¥</div>
        <div class="reaction-option" data-reaction="ðŸŽ‰">ðŸŽ‰</div>
      </div>
    </div>
  </div>

  <!-- Notes Modal -->
  <div class="modal" id="notes-modal">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h3>ðŸ“ Notes</h3>
        <button class="modal-close" id="close-notes">&times;</button>
      </div>
      <div style="display: flex; gap: 16px;">
        <div style="flex: 1;">
          <div class="input-group">
            <label for="note-title">Title</label>
            <input type="text" id="note-title" placeholder="Note title">
          </div>
          <div class="input-group">
            <label for="note-content">Content</label>
            <textarea id="note-content" rows="10" placeholder="Write your note here..."></textarea>
          </div>
          <div style="display: flex; gap: 8px; margin-top: 12px;">
            <button id="save-note-btn" style="flex: 1;">
              <i class="fas fa-save"></i> Save Note
            </button>
            <button id="new-note-btn" style="background: var(--bg-card);">
              <i class="fas fa-plus"></i> New
            </button>
          </div>
        </div>
        <div style="flex: 1; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 16px;">
          <h4>Your Notes</h4>
          <div id="notes-list" style="max-height: 400px; overflow-y: auto;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="context-menu"></div>

  <script>
    // Notification System
    class NotificationManager {
      constructor() {
        this.container = document.getElementById('notification-container');
        this.toggle = document.getElementById('notification-toggle');
        this.notifications = new Map();
        this.isEnabled = localStorage.getItem('notifications-enabled') !== 'false';
        this.pushSubscription = null;
        
        this.init();
      }

      async init() {
        // Set up notification toggle
        this.updateToggleState();
        this.toggle.addEventListener('click', () => this.toggleNotifications());
        
        // Set up test notification button
        const testBtn = document.getElementById('test-notification');
        if (testBtn) {
          testBtn.addEventListener('click', () => this.testNotification());
        }
        
        // Register service worker
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.register('/sw.js');
            console.log('Service Worker registered:', registration);
            
            // Set up push notifications
            await this.setupPushNotifications();
          } catch (error) {
            console.error('Service Worker registration failed:', error);
          }
        }
      }

      async setupPushNotifications() {
        if (!('Notification' in window) || !('PushManager' in window)) {
          console.log('Push notifications not supported');
          return;
        }

        // Request notification permission
        if (Notification.permission === 'default') {
          const permission = await Notification.requestPermission();
          if (permission !== 'granted') {
            console.log('Notification permission denied');
            return;
          }
        }

        // Subscribe to push notifications
        try {
          const registration = await navigator.serviceWorker.ready;
          this.pushSubscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: this.urlBase64ToUint8Array('BEl62iUYgUivxIkv69yViEuiBIa40HI0pO7OQ6VxguUtXr3QzRHPDsK1n8vU0cd2ZJk1S7qt3iLGliVsou46iM')
          });
          
          console.log('Push subscription:', this.pushSubscription);
        } catch (error) {
          console.error('Push subscription failed:', error);
        }
      }

      urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding)
          .replace(/-/g, '+')
          .replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
          outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
      }

      toggleNotifications() {
        this.isEnabled = !this.isEnabled;
        localStorage.setItem('notifications-enabled', this.isEnabled.toString());
        this.updateToggleState();
        
        if (this.isEnabled) {
          this.showInAppNotification('Notifications Enabled', 'You will now receive notifications for new messages', 'success');
        } else {
          this.showInAppNotification('Notifications Disabled', 'You will no longer receive notifications', 'info');
        }
      }

      updateToggleState() {
        if (this.isEnabled) {
          this.toggle.classList.remove('disabled');
          this.toggle.innerHTML = '<i class="fas fa-bell"></i>';
        } else {
          this.toggle.classList.add('disabled');
          this.toggle.innerHTML = '<i class="fas fa-bell-slash"></i>';
        }
      }

      showInAppNotification(title, body, type = 'message', duration = 5000) {
        if (!this.isEnabled) return;

        // Play notification sound
        this.playNotificationSound();

        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
          <div class="notification-header">
            <div class="notification-title">
              <div class="notification-icon">
                <i class="fas fa-${this.getIconForType(type)}"></i>
              </div>
              ${title}
            </div>
            <button class="notification-close">&times;</button>
          </div>
          <div class="notification-body">${body}</div>
          <div class="notification-meta">${new Date().toLocaleTimeString()}</div>
          <div class="notification-progress"></div>
        `;

        // Add close functionality
        notification.querySelector('.notification-close').addEventListener('click', () => {
          this.hideNotification(notification);
        });

        // Add click to open functionality
        notification.addEventListener('click', () => {
          this.hideNotification(notification);
          // Focus the app window
          window.focus();
        });

        this.container.appendChild(notification);

        // Animate in
        setTimeout(() => notification.classList.add('show'), 100);

        // Auto-hide after duration
        const progressBar = notification.querySelector('.notification-progress');
        progressBar.style.width = '100%';
        progressBar.style.transition = `width ${duration}ms linear`;

        setTimeout(() => {
          this.hideNotification(notification);
        }, duration);

        // Store reference
        const id = Date.now() + Math.random();
        this.notifications.set(id, notification);
        return id;
      }

      hideNotification(notification) {
        notification.classList.add('hide');
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }

      getIconForType(type) {
        const icons = {
          'message': 'comment',
          'friend-request': 'user-plus',
          'group-invite': 'users',
          'error': 'exclamation-triangle',
          'success': 'check-circle',
          'info': 'info-circle'
        };
        return icons[type] || 'bell';
      }

      // Method to show notifications for new messages
      showMessageNotification(sender, message, chatType, chatId) {
        if (!this.isEnabled) return;

        const title = `${sender}`;
        const body = message.length > 50 ? message.substring(0, 50) + '...' : message;
        
        this.showInAppNotification(title, body, 'message', 6000);
        
        // Also show browser notification if permission granted and tab not focused
        if (Notification.permission === 'granted' && document.hidden) {
          new Notification(title, {
            body: body,
            icon: '/icon-192.png',
            tag: `message-${chatId}`,
            requireInteraction: true
          });
        }
      }

      showFriendRequestNotification(sender) {
        if (!this.isEnabled) return;
        
        this.showInAppNotification('New Friend Request', `${sender} wants to be your friend`, 'friend-request', 8000);
      }

      showGroupInviteNotification(groupName, inviter) {
        if (!this.isEnabled) return;
        
        this.showInAppNotification('Group Invitation', `${inviter} invited you to join "${groupName}"`, 'group-invite', 8000);
      }

      showGroupActivityNotification(activity, user, groupName) {
        if (!this.isEnabled) return;
        
        const messages = {
          'joined': `${user} joined "${groupName}"`,
          'left': `${user} left "${groupName}"`,
          'created': `${user} created "${groupName}"`
        };
        
        this.showInAppNotification('Group Activity', messages[activity] || activity, 'info', 5000);
      }

      playNotificationSound() {
        try {
          // Create a simple notification sound using Web Audio API
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
          oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
          
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.2);
        } catch (error) {
          console.log('Could not play notification sound:', error);
        }
      }

      testNotification() {
        this.showInAppNotification(
          'Test Notification', 
          'This is a test notification to verify the system is working properly!', 
          'info', 
          5000
        );
      }
    }

    // Initialize notification manager
    const notificationManager = new NotificationManager();

    // Handle page visibility changes for better notification behavior
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Page is hidden, notifications will be shown as browser notifications
        console.log('Page hidden - browser notifications will be used');
      } else {
        // Page is visible, focus on in-app notifications
        console.log('Page visible - in-app notifications will be used');
      }
    });

    // Missing functions that were in CSS section
    function scheduleMessage() {
      const when = new Date(scheduleTimeInput?.value).getTime();
      if (!when || when < Date.now() + 1000) {
        return showStatus(chatStatus, 'Pick a time in the future', 'error');
      }
      const draft = messageInput.value.trim();
      if (!draft) return showStatus(chatStatus, 'Type a message to schedule', 'error');
      const delay = when - Date.now();
      showStatus(chatStatus, `Scheduled in ${Math.ceil(delay/1000)}s`, 'success');
      setTimeout(() => {
        if (messageInput.value.trim() === draft) sendText();
      }, delay);
    }

    function markMessageRead(chatId, messageId, notifyOnly = false) {
      const path = `messages/${currentChat.type}/${chatId}/${messageId}/readBy/${currentUser.username}`;
      db.ref(path).set(true);
      if (!notifyOnly) return;
    }

    function promptThreadReply(messageId, message) {
      const reply = prompt('Reply:', '');
      if (!reply) return;
      const chatId = getChatId(currentChat.id, currentChat.type);
      db.ref(`messages/${currentChat.type}/${chatId}`).push({
        type: 'text',
        text: reply,
        threadParent: messageId,
        threadParentPreview: (message.text || '').slice(0, 80),
        time: Date.now(), username: currentUser.username, userId: currentUser.username
      });
    }

    async function searchGifs() {
      const q = gifSearch?.value.trim();
      if (!q) return;
      gifResults.innerHTML = 'Searching...';
      const res = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=dc6zaTOxFJmzC&q=${encodeURIComponent(q)}&limit=12`);
      const data = await res.json();
      gifResults.innerHTML = '';
      (data.data || []).forEach(g => {
        const url = g.images.fixed_height_small.url;
        const el = document.createElement('img');
        el.src = url; el.style.width = '100%'; el.style.cursor = 'pointer';
        el.addEventListener('click', async () => {
          const chatId = getChatId(currentChat.id, currentChat.type);
          await db.ref(`messages/${currentChat.type}/${chatId}`).push({ type:'image', url, time: Date.now(), username: currentUser.username, userId: currentUser.username });
          emojiGifModal.classList.remove('active');
        });
        gifResults.appendChild(el);
      });
    }


    function launchGame(game) {
      if (!currentChat) {
        showStatus(chatStatus, 'Open a chat first', 'error');
        return;
      }
      
      const chatId = getChatId(currentChat.id, currentChat.type);
      const gameId = `${game}_${Date.now()}`;
      
      // Initialize game state based on game type
      let gameState = {};
      switch(game) {
        case 'tictactoe':
          gameState = {
            board: ['', '', '', '', '', '', '', '', ''],
            currentPlayer: 'X',
            winner: null,
            gameOver: false
          };
          break;
        case 'uno':
          gameState = {
            deck: generateUNODeck(),
            currentCard: null,
            players: {},
            currentPlayer: 0,
            direction: 1,
            gameOver: false
          };
          break;
        default:
          gameState = {};
      }
      
      const payload = { 
        type: 'game', 
        game, 
        gameId,
        status: 'waiting',
        players: [currentUser.username],
        gameState: gameState,
        createdAt: Date.now(),
        username: currentUser.username, 
        userId: currentUser.username, 
        time: Date.now() 
      };
      
      console.log('Launching game:', game, 'in chat:', chatId);
      
      // Create game in database
      db.ref(`games/${gameId}`).set(payload).then(() => {
        // Add game message to chat
        db.ref(`messages/${currentChat.type}/${chatId}`).push({
          type: 'game',
          game: game,
          gameId: gameId,
          status: 'waiting',
          players: [currentUser.username],
          time: Date.now(),
          username: currentUser.username,
          userId: currentUser.username
        }).then(() => {
          showStatus(chatStatus, `Game "${game}" launched! Waiting for players...`, 'success');
          gamesModal.classList.remove('active');
          
          // Show game interface
          showGameInterface(game, gameId);
        });
      }).catch((error) => {
        console.error('Error launching game:', error);
        showStatus(chatStatus, 'Error launching game', 'error');
      });
    }

    function generateUNODeck() {
      const colors = ['red', 'blue', 'green', 'yellow'];
      const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const specials = ['skip', 'reverse', 'draw2'];
      let deck = [];
      
      // Add number cards
      colors.forEach(color => {
        numbers.forEach(number => {
          deck.push({ color, number, type: 'number' });
          if (number > 0) deck.push({ color, number, type: 'number' }); // Two of each except 0
        });
      });
      
      // Add special cards
      colors.forEach(color => {
        specials.forEach(special => {
          deck.push({ color, special, type: 'special' });
          deck.push({ color, special, type: 'special' }); // Two of each
        });
      });
      
      // Add wild cards
      for (let i = 0; i < 4; i++) {
        deck.push({ color: 'wild', special: 'wild', type: 'wild' });
        deck.push({ color: 'wild', special: 'wild4', type: 'wild' });
      }
      
      // Shuffle deck
      return deck.sort(() => Math.random() - 0.5);
    }

    function showGameInterface(game, gameId) {
      const gameContainer = document.getElementById('game-container');
      if (!gameContainer) return;
      
      if (game === 'tictactoe') {
        renderTicTacToe(gameId);
      } else if (game === 'uno') {
        renderUNO(gameId);
      }
    }

    function joinGame(gameType, gameId) {
      if (!currentUser) {
        showStatus(chatStatus, 'Please log in to join games', 'error');
        return;
      }

      db.ref(`games/${gameId}`).once('value').then(snapshot => {
        const game = snapshot.val();
        if (!game) {
          showStatus(chatStatus, 'Game not found', 'error');
          return;
        }

        if (game.players.includes(currentUser.username)) {
          showStatus(chatStatus, 'You are already in this game', 'info');
          return;
        }

        if (game.players.length >= (gameType === 'uno' ? 8 : 2)) {
          showStatus(chatStatus, 'Game is full', 'error');
          return;
        }

        // Add player to game
        const updatedPlayers = [...game.players, currentUser.username];
        db.ref(`games/${gameId}/players`).set(updatedPlayers).then(() => {
          showStatus(chatStatus, `Joined ${gameType} game!`, 'success');
          
          // Update the game message in chat
          const chatId = getChatId(currentChat.id, currentChat.type);
          db.ref(`messages/${currentChat.type}/${chatId}`).orderByChild('gameId').equalTo(gameId).once('value').then(msgSnapshot => {
            msgSnapshot.forEach(msg => {
              db.ref(`messages/${currentChat.type}/${chatId}/${msg.key}/players`).set(updatedPlayers);
            });
          });
        });
      });
    }

    function startGame(gameType, gameId) {
      if (!currentUser) {
        showStatus(chatStatus, 'Please log in to start games', 'error');
        return;
      }

      db.ref(`games/${gameId}`).once('value').then(snapshot => {
        const game = snapshot.val();
        if (!game) {
          showStatus(chatStatus, 'Game not found', 'error');
          return;
        }

        if (!game.players.includes(currentUser.username)) {
          showStatus(chatStatus, 'You are not in this game', 'error');
          return;
        }

        if (game.players.length < 2) {
          showStatus(chatStatus, 'Need at least 2 players to start', 'error');
          return;
        }

        // Start the game
        const updates = {
          status: 'playing',
          gameState: {
            ...game.gameState,
            currentPlayer: game.players[0],
            gameStarted: true
          }
        };

        db.ref(`games/${gameId}`).update(updates).then(() => {
          showStatus(chatStatus, `${gameType} game started!`, 'success');
          
          // Update the game message in chat
          const chatId = getChatId(currentChat.id, currentChat.type);
          db.ref(`messages/${currentChat.type}/${chatId}`).orderByChild('gameId').equalTo(gameId).once('value').then(msgSnapshot => {
            msgSnapshot.forEach(msg => {
              db.ref(`messages/${currentChat.type}/${chatId}/${msg.key}`).update({
                status: 'playing'
              });
            });
          });

          // Show game interface
          showGameInterface(gameType, gameId);
        });
      });
    }

    function renderGameMessage(msg) {
      const status = msg.status || 'waiting';
      const players = msg.players || [];
      const playerCount = players.length;
      const maxPlayers = msg.game === 'uno' ? 8 : 2;
      const isPlayer = players.includes(currentUser.username);
      
      let statusText = '';
      if (status === 'waiting') {
        statusText = `Waiting for players (${playerCount}/${maxPlayers})`;
      } else if (status === 'playing') {
        statusText = `In progress - ${msg.gameState?.currentPlayer || 'Unknown'}'s turn`;
      } else if (status === 'finished') {
        statusText = `Game finished - ${msg.gameState?.winner || 'No winner'} won`;
      }
      
      let actionButtons = '';
      if (status === 'waiting' && playerCount < maxPlayers && !isPlayer) {
        actionButtons = `<button class="join-game-btn" onclick="joinGame('${msg.game}', '${msg.gameId}')" style="margin-top: 8px; padding: 4px 8px; font-size: 12px; background: var(--accent); border: none; border-radius: 4px; color: white; cursor: pointer;">Join Game</button>`;
      } else if (isPlayer && status === 'waiting' && playerCount >= 2) {
        actionButtons = `<button class="start-game-btn" onclick="startGame('${msg.game}', '${msg.gameId}')" style="margin-top: 8px; padding: 4px 8px; font-size: 12px; background: var(--success); border: none; border-radius: 4px; color: white; cursor: pointer;">Start Game</button>`;
      } else if (isPlayer && status === 'playing') {
        actionButtons = `<button class="view-game-btn" onclick="playGame('${msg.game}', '${msg.gameId}')" style="margin-top: 8px; padding: 4px 8px; font-size: 12px; background: var(--info); border: none; border-radius: 4px; color: white; cursor: pointer;">View Game</button>`;
      }
      
      return `<div style="padding:12px; background: rgba(255,255,255,0.05); border-radius:8px; border: 1px solid rgba(255,255,255,0.1);">
        <div><b>ðŸŽ® ${msg.game.toUpperCase()}</b></div>
        <div style="font-size:12px; opacity:0.8; margin: 4px 0;">${statusText}</div>
        <div style="font-size:11px; opacity:0.6;">Players: ${players.join(', ')}</div>
        ${actionButtons}
      </div>`;
    }

    // Enhanced TicTacToe game with multiplayer support
    function renderTicTacToe(gameId = null) {
      const container = document.getElementById('game-container');
      container.innerHTML = `
        <div style="text-align: center; padding: 20px;">
          <h3>ðŸŽ® TIC TAC TOE</h3>
          <div id="tictactoe-status" style="margin-bottom: 16px; font-weight: bold;">Loading game...</div>
          <div id="tictactoe-board" style="display: grid; grid-template-columns: repeat(3, 80px); gap: 4px; margin: 0 auto; width: fit-content;"></div>
          <div style="margin-top: 16px;">
            <button id="join-tictactoe-btn" style="padding:8px 16px; background: var(--accent); border:none; border-radius:4px; color:white; cursor:pointer; margin-right:8px;">
              Join Game
            </button>
            <button onclick="gamesModal.classList.remove('active')" style="padding:8px 16px; background: var(--bg-card); border:none; border-radius:4px; color:white; cursor:pointer;">
              Close
            </button>
          </div>
        </div>
      `;
      
      if (gameId) {
        // Join existing game
        joinGame('tictactoe', gameId);
      } else {
        // Create new game
        createNewGame('tictactoe');
      }
    }

    // UNO Game Implementation
    function renderUNO(gameId = null) {
      const container = document.getElementById('game-container');
      container.innerHTML = `
        <div style="text-align: center; padding: 20px;">
          <h3>ðŸŽ´ UNO</h3>
          <div id="uno-status" style="margin-bottom: 16px; font-weight: bold;">Loading game...</div>
          <div id="uno-game-area" style="display: none;">
            <div id="uno-current-card" style="margin: 16px; padding: 20px; background: white; border-radius: 8px; display: inline-block; font-size: 24px; color: black;">
              ðŸƒ
            </div>
            <div id="uno-player-hand" style="margin: 16px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;"></div>
          </div>
          <div style="margin-top: 16px;">
            <button id="join-uno-btn" style="padding:8px 16px; background: var(--accent); border:none; border-radius:4px; color:white; cursor:pointer; margin-right:8px;">
              Join Game
            </button>
            <button onclick="gamesModal.classList.remove('active')" style="padding:8px 16px; background: var(--bg-card); border:none; border-radius:4px; color:white; cursor:pointer;">
              Close
            </button>
          </div>
        </div>
      `;
      
      if (gameId) {
        // Join existing game
        joinGame('uno', gameId);
      } else {
        // Create new game
        createNewGame('uno');
      }
    }

    // Game management functions
    function createNewGame(gameType) {
      const gameId = `${gameType}_${Date.now()}`;
      const chatId = getChatId(currentChat.id, currentChat.type);
      
      const gameData = {
        type: gameType,
        gameId: gameId,
        status: 'waiting',
        players: [currentUser.username],
        currentPlayer: currentUser.username,
        gameState: gameType === 'uno' ? initializeUNOState() : initializeTicTacToeState(),
        createdAt: Date.now()
      };
      
      db.ref(`games/${gameId}`).set(gameData).then(() => {
        // Add game message to chat
        db.ref(`messages/${currentChat.type}/${chatId}`).push({
          type: 'game',
          game: gameType,
          gameId: gameId,
          status: 'waiting',
          players: [currentUser.username],
          state: gameData,
          username: currentUser.username,
          userId: currentUser.username,
          time: Date.now()
        });
        
        showStatus(chatStatus, `${gameType.toUpperCase()} game created! Waiting for players...`, 'success');
        
        // Start watching the game
        watchGame(gameType, gameId);
      });
    }

    function joinGame(gameType, gameId) {
      db.ref(`games/${gameId}`).once('value').then(snapshot => {
        const game = snapshot.val();
        if (!game) {
          showStatus(chatStatus, 'Game not found', 'error');
          return;
        }
        
        if (game.players.includes(currentUser.username)) {
          // Already in game, just watch
          watchGame(gameType, gameId);
        } else if (game.status === 'waiting') {
          // Join the game
          const updates = {};
          updates[`games/${gameId}/players/${game.players.length}`] = currentUser.username;
          db.ref().update(updates).then(() => {
            watchGame(gameType, gameId);
            showStatus(chatStatus, `Joined ${gameType} game!`, 'success');
          });
        } else {
          showStatus(chatStatus, 'Game already in progress', 'error');
        }
      });
    }

    function watchGame(gameType, gameId) {
      db.ref(`games/${gameId}`).on('value', snapshot => {
        const game = snapshot.val();
        if (!game) return;
        
        console.log('Game update:', game);
        
        // Update game status in chat message
        if (currentChat) {
          const chatId = getChatId(currentChat.id, currentChat.type);
          db.ref(`messages/${currentChat.type}/${chatId}`).orderByChild('gameId').equalTo(gameId).once('value')
            .then(snapshot => {
              snapshot.forEach(childSnapshot => {
                db.ref(`messages/${currentChat.type}/${chatId}/${childSnapshot.key}`).update({
                  status: game.status,
                  players: game.players,
                  state: game.gameState
                });
              });
            });
        }
        
        if (gameType === 'uno') {
          updateUNODisplay(game);
        } else if (gameType === 'tictactoe') {
          updateTicTacToeDisplay(game);
        }
      });
    }

    // UNO Game Logic
    function initializeUNOState() {
      const colors = ['red', 'blue', 'green', 'yellow'];
      const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
      const specials = ['skip', 'reverse', 'draw2', 'wild', 'wild4'];
      
      let deck = [];
      
      // Add number cards
      colors.forEach(color => {
        numbers.forEach(number => {
          deck.push({ color, number, type: 'number' });
        });
      });
      
      // Add special cards
      colors.forEach(color => {
        specials.slice(0, 3).forEach(special => {
          deck.push({ color, special, type: 'special' });
        });
      });
      
      // Add wild cards
      for (let i = 0; i < 4; i++) {
        deck.push({ color: 'wild', special: 'wild', type: 'wild' });
        deck.push({ color: 'wild', special: 'wild4', type: 'wild' });
      }
      
      // Shuffle deck
      deck = deck.sort(() => Math.random() - 0.5);
      
      return {
        deck: deck,
        discardPile: [deck.pop()],
        playerHands: {},
        currentColor: deck[0].color !== 'wild' ? deck[0].color : 'red',
        direction: 1, // 1 for clockwise, -1 for counter-clockwise
        currentPlayerIndex: 0
      };
    }

    function updateUNODisplay(game) {
      const statusEl = document.getElementById('uno-status');
      const gameArea = document.getElementById('uno-game-area');
      const currentCardEl = document.getElementById('uno-current-card');
      const playerHandEl = document.getElementById('uno-player-hand');
      
      if (game.status === 'waiting') {
        statusEl.textContent = `Waiting for players (${game.players.length}/8)`;
        gameArea.style.display = 'none';
        return;
      }
      
      gameArea.style.display = 'block';
      statusEl.textContent = `Current player: ${game.currentPlayer}`;
      
      // Show current card
      const topCard = game.gameState.discardPile[game.gameState.discardPile.length - 1];
      if (topCard) {
        const cardColor = topCard.color === 'wild' ? game.gameState.currentColor : topCard.color;
        const cardSymbol = topCard.number || topCard.special || 'ðŸƒ';
        currentCardEl.style.backgroundColor = cardColor;
        currentCardEl.textContent = cardSymbol;
      }
      
      // Show player's hand
      const playerHand = game.gameState.playerHands[currentUser.username] || [];
      playerHandEl.innerHTML = '';
      
      playerHand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.style.cssText = `
          padding: 8px 12px;
          background: ${card.color === 'wild' ? 'linear-gradient(45deg, red, blue, green, yellow)' : card.color};
          border-radius: 4px;
          color: white;
          cursor: pointer;
          font-weight: bold;
          border: 2px solid ${game.currentPlayer === currentUser.username ? 'gold' : 'transparent'};
        `;
        cardEl.textContent = card.number || card.special || 'ðŸƒ';
        cardEl.onclick = () => playUNOCard(gameId, index);
        playerHandEl.appendChild(cardEl);
      });
    }

    function playUNOCard(gameId, cardIndex) {
      // UNO card playing logic would go here
      console.log('Playing UNO card:', cardIndex);
    }

    // TicTacToe Game Logic
    function initializeTicTacToeState() {
      return {
        board: Array(9).fill(null),
        currentPlayer: 'X',
        winner: null,
        gameOver: false
      };
    }

    function updateTicTacToeDisplay(game) {
      const statusEl = document.getElementById('tictactoe-status');
      const boardEl = document.getElementById('tictactoe-board');
      
      if (!statusEl || !boardEl) return;
      
      if (game.status === 'waiting') {
        statusEl.textContent = `Waiting for players (${game.players.length}/2)`;
        boardEl.innerHTML = '<div style="text-align: center; padding: 20px; opacity: 0.7;">Waiting for more players to join...</div>';
        return;
      }
      
      // Start game if we have 2 players and status is still waiting
      if (game.players.length >= 2 && game.status === 'waiting') {
        db.ref(`games/${game.gameId || 'tictactoe'}`).update({
          status: 'playing',
          currentPlayer: game.players[0]
        });
        return;
      }
      
      if (game.status === 'playing') {
        statusEl.textContent = `Current player: ${game.gameState.currentPlayer}`;
        
        boardEl.innerHTML = '';
        game.gameState.board.forEach((cell, index) => {
          const cellEl = document.createElement('button');
          cellEl.textContent = cell || '';
          cellEl.style.cssText = `
            width: 80px;
            height: 80px;
            font-size: 24px;
            background: var(--bg-card);
            color: var(--text-primary);
            border: none;
            border-radius: 4px;
            cursor: ${game.gameState.currentPlayer === currentUser.username && !cell ? 'pointer' : 'not-allowed'};
          `;
          cellEl.disabled = cell || game.gameState.currentPlayer !== currentUser.username || game.gameState.gameOver;
          cellEl.onclick = () => playTicTacToeMove(game.gameId || 'tictactoe', index);
          boardEl.appendChild(cellEl);
        });
        
        if (game.gameState.winner) {
          statusEl.textContent = `Winner: ${game.gameState.winner}`;
        } else if (game.gameState.gameOver) {
          statusEl.textContent = 'Game ended in a draw!';
        }
      }
    }

    function playTicTacToeMove(gameId, position) {
      console.log('Playing move:', position, 'in game:', gameId);
      
      db.ref(`games/${gameId}`).once('value').then(snapshot => {
        const game = snapshot.val();
        if (!game || !game.gameState) return;
        
        const gameState = game.gameState;
        if (gameState.board[position] || gameState.gameOver) return;
        if (game.currentPlayer !== currentUser.username) return;
        
        const newState = { ...gameState };
        newState.board[position] = newState.currentPlayer;
        
        // Check for winner
        const lines = [
          [0,1,2],[3,4,5],[6,7,8],
          [0,3,6],[1,4,7],[2,5,8],
          [0,4,8],[2,4,6]
        ];
        
        for (const [a,b,c] of lines) {
          if (newState.board[a] && newState.board[a] === newState.board[b] && newState.board[a] === newState.board[c]) {
            newState.winner = newState.board[a];
            newState.gameOver = true;
            break;
          }
        }
        
        if (!newState.winner && newState.board.every(cell => cell)) {
          newState.gameOver = true;
        }
        
        if (!newState.gameOver) {
          newState.currentPlayer = newState.currentPlayer === 'X' ? 'O' : 'X';
        }
        
        // Update game state
        db.ref(`games/${gameId}`).update({
          gameState: newState,
          currentPlayer: newState.currentPlayer,
          status: newState.gameOver ? 'finished' : 'playing'
        });
      });
    }

    function playGame(gameName, gameId = null) {
      console.log('Playing game:', gameName, 'Game ID:', gameId);
      
      // Open games modal and show the specific game
      gamesModal.classList.add('active');
      
      const gameContainer = document.getElementById('game-container');
      if (!gameContainer) return;
      
      if (gameName === 'tictactoe') {
        renderTicTacToe(gameId);
        return;
      } else if (gameName === 'uno') {
        renderUNO(gameId);
        return;
      }
      
      // For other games, show waiting status
      gameContainer.innerHTML = `
        <div style="text-align: center; padding: 20px;">
          <h3>ðŸŽ® ${gameName.toUpperCase()}</h3>
          <p>Waiting for players...</p>
          <button onclick="gamesModal.classList.remove('active')" style="padding:8px 16px; background: var(--accent); border:none; border-radius:4px; color:white; cursor:pointer;">
            Close
          </button>
        </div>
      `;
    }

    function postStatus() {
      const text = document.getElementById('status-text')?.value.trim();
      if (!text) return;
      db.ref(`status/${currentUser.username}`).push({ text: maybeEncrypt(text), time: Date.now() });
      document.getElementById('status-text').value = '';
      loadStatusFeed();
    }

    function loadStatusFeed() {
      const feed = document.getElementById('status-feed');
      if (!feed) return;
      feed.innerHTML = 'Loading...';
      db.ref('status').limitToLast(50).once('value', snap => {
        const all = snap.val() || {};
        const items = [];
        Object.entries(all).forEach(([user, posts]) => {
          Object.values(posts).forEach(p => items.push({ user, ...p }));
        });
        items.sort((a,b)=>b.time-a.time);
        feed.innerHTML = items.map(i => `<div style=\"padding:8px; background: rgba(255,255,255,0.06); border-radius:8px; margin:6px 0;\"><b>${i.user}</b>: ${maybeDecrypt(i.text || '')} <span style=\"opacity:.6;font-size:11px;\">${formatTime(i.time)}</span></div>`).join('');
      });
    }

    function showScheduleModal() {
      const when = prompt('Schedule for (YYYY-MM-DD HH:MM):', '');
      if (!when) return;
      const time = new Date(when).getTime();
      if (isNaN(time) || time < Date.now()) {
        alert('Please enter a valid future time');
        return;
      }
      const delay = time - Date.now();
      showStatus(chatStatus, `Message scheduled for ${when}`, 'success');
      setTimeout(() => sendText(), delay);
    }
    
    function showTTLModal() {
      const ttl = prompt('Message expires in (minutes, 0 for no expiry):', '0');
      const ttlMs = parseInt(ttl) * 60 * 1000;
      if (isNaN(ttlMs) || ttlMs < 0) {
        alert('Please enter a valid number');
        return;
      }
      window.nextMessageTTL = ttlMs;
      showStatus(chatStatus, `Next message expires in ${ttl} minutes`, 'success');
    }
    
    async function shareMusic() {
      const url = document.getElementById('music-url')?.value.trim();
      if (!url || !currentChat) return;
      const chatId = getChatId(currentChat.id, currentChat.type);
      await db.ref(`messages/${currentChat.type}/${chatId}`).push({ type:'text', text: maybeEncrypt(`[Music] ${url}`), music:{ url }, time: Date.now(), username: currentUser.username, userId: currentUser.username });
      document.getElementById('music-modal').classList.remove('active');
      document.getElementById('music-url').value = '';
    }

    function runMessageSearch() {
      const q = document.getElementById('search-query')?.value.toLowerCase() || '';
      const results = document.getElementById('search-results'); 
      if (!results) return;
      results.innerHTML = '';
      const chatId = currentChat ? getChatId(currentChat.id, currentChat.type) : null;
      if (!chatId || !q) return;
      db.ref(`messages/${currentChat.type}/${chatId}`).orderByChild('time').once('value', snap => {
        const all = snap.val() || {};
        const matched = Object.entries(all).filter(([id, m]) => (maybeDecrypt(m.text || '')).toLowerCase().includes(q));
        matched.sort((a,b)=>a[1].time-b[1].time);
        results.innerHTML = matched.map(([id, m]) => `<div style=\"padding:6px; border-bottom:1px solid rgba(255,255,255,0.06);\">${formatTime(m.time)} â€” ${maybeDecrypt(m.text || '')}</div>`).join('');
      });
    }

    function addPollOption() {
      const input = document.createElement('input');
      input.className = 'poll-option';
      input.placeholder = 'Another option';
      pollsModalEl?.querySelector('.input-group:last-of-type').insertBefore(input, createPollBtn);
    }

    async function createPoll() {
      const question = pollQuestion?.value.trim();
      const options = Array.from(document.querySelectorAll('.poll-option')).map(i => i.value.trim()).filter(Boolean);
      if (!question || options.length < 2) return showStatus(chatStatus, 'Need a question and 2+ options', 'error');
      const chatId = getChatId(currentChat.id, currentChat.type);
      await db.ref(`messages/${currentChat.type}/${chatId}`).push({ type:'poll', question, options, votes: {}, time: Date.now(), username: currentUser.username, userId: currentUser.username });
      pollsModalEl.classList.remove('active');
    }

    function renderPollMessage(msg, id, isSelf) {
      const optionsHtml = msg.options.map((opt, idx) => `<button class="vote-btn" data-id="${id}" data-idx="${idx}">${opt}</button>`).join(' ');
      const results = msg.votes ? Object.values(msg.votes) : [];
      const counts = msg.options.map((_, i) => results.filter(v => v === i).length);
      return `
        <div><b>${msg.question}</b></div>
        <div style="display:flex; gap:6px; margin:6px 0;">${optionsHtml}</div>
        <div style="font-size: 12px; opacity: 0.8;">${counts.map((c,i)=>`${msg.options[i]}: ${c}`).join(' â€¢ ')}</div>
      `;
    }

    // Add vote button event listener
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('.vote-btn');
      if (!btn) return;
      const id = btn.dataset.id;
      const idx = parseInt(btn.dataset.idx, 10);
      const chatId = getChatId(currentChat.id, currentChat.type);
      db.ref(`messages/${currentChat.type}/${chatId}/${id}/votes/${currentUser.username}`).set(idx);
    });

    function setupDrawing(canvas, colorInput, sizeInput) {
      const ctx = canvas.getContext('2d');
      let drawing = false; let last = null;
      canvas.addEventListener('mousedown', (e) => { drawing = true; last = [e.offsetX, e.offsetY]; });
      canvas.addEventListener('mouseup', () => drawing = false);
      canvas.addEventListener('mouseleave', () => drawing = false);
      canvas.addEventListener('mousemove', (e) => {
        if (!drawing) return;
        ctx.strokeStyle = colorInput.value; ctx.lineWidth = parseInt(sizeInput.value, 10); ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(last[0], last[1]); ctx.lineTo(e.offsetX, e.offsetY); ctx.stroke(); last = [e.offsetX, e.offsetY];
      });
    }

    function clearCanvas(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    async function sendDrawing() {
      const blob = await new Promise((resolve) => drawCanvas.toBlob(resolve));
      const storageRef = storage.ref().child(`draw/${currentUser.username}/draw_${Date.now()}.png`);
      await storageRef.put(blob);
      const url = await storageRef.getDownloadURL();
      const chatId = getChatId(currentChat.id, currentChat.type);
      await db.ref(`messages/${currentChat.type}/${chatId}`).push({ type:'image', url, time: Date.now(), username: currentUser.username, userId: currentUser.username });
      drawModalEl.classList.remove('active');
      showStatus(chatStatus, 'Drawing sent', 'success');
    }

    function setupWhiteboard() {
      const ctx = whiteboardCanvas.getContext('2d');
      let drawing = false; let last = null;
      const chatId = () => currentChat ? getChatId(currentChat.id, currentChat.type) : null;
      whiteboardCanvas.addEventListener('mousedown', (e) => { drawing = true; last = [e.offsetX, e.offsetY]; });
      whiteboardCanvas.addEventListener('mouseup', () => drawing = false);
      whiteboardCanvas.addEventListener('mouseleave', () => drawing = false);
      whiteboardCanvas.addEventListener('mousemove', (e) => {
        if (!drawing || !currentChat) return;
        const stroke = { x1:last[0], y1:last[1], x2:e.offsetX, y2:e.offsetY, color: whiteboardColor.value, size: parseInt(whiteboardSize.value, 10) };
        db.ref(`whiteboard/${currentChat.type}/${chatId()}`).push(stroke);
        drawStroke(ctx, stroke);
        last = [e.offsetX, e.offsetY];
      });
      whiteboardClear.addEventListener('click', () => {
        if (!currentChat) return; db.ref(`whiteboard/${currentChat.type}/${chatId()}`).remove(); ctx.clearRect(0,0,whiteboardCanvas.width, whiteboardCanvas.height);
      });
      setInterval(() => {
        if (!currentChat) return; 
        db.ref(`whiteboard/${currentChat.type}/${chatId()}`).off('child_added');
        db.ref(`whiteboard/${currentChat.type}/${chatId()}`).on('child_added', snap => drawStroke(ctx, snap.val()));
      }, 1000);
      function drawStroke(ctx, s) { ctx.strokeStyle = s.color; ctx.lineWidth = s.size; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke(); }
    }



    async function startCall(video) {
      if (!currentChat) return showStatus(chatStatus, 'Open a chat first', 'error');
      if (currentChat.type !== 'friend') return showStatus(chatStatus, 'Calls are 1:1 for now', 'error');
      isVideoCall = !!video;
      callModal.classList.add('active');
      callStatus.textContent = 'Starting call...'; callStatus.className = 'status loading';
      const chatId = getChatId(currentChat.id, currentChat.type);
      const config = { iceServers: [ { urls: 'stun:stun.l.google.com:19302' } ] };
      rtcPeerConnection = new RTCPeerConnection(config);
      rtcRemoteStream = new MediaStream();
      remoteVideo.srcObject = rtcRemoteStream;
      rtcPeerConnection.ontrack = (e) => e.streams[0].getTracks().forEach(t => rtcRemoteStream.addTrack(t));
      rtcPeerConnection.onicecandidate = (e) => { if (e.candidate) db.ref(`calls/${chatId}/candidates`).push(JSON.parse(JSON.stringify(e.candidate))); };
      try {
        rtcLocalStream = await navigator.mediaDevices.getUserMedia({ audio: true, video });
        rtcLocalStream.getTracks().forEach(t => rtcPeerConnection.addTrack(t, rtcLocalStream));
        localVideo.srcObject = rtcLocalStream;
        screenShareBtn.style.display = video ? 'inline-flex' : 'none';
        const offer = await rtcPeerConnection.createOffer();
        await rtcPeerConnection.setLocalDescription(offer);
        await db.ref(`calls/${chatId}`).set({ offer: offer.toJSON(), caller: currentUser.username, createdAt: Date.now() });
        db.ref(`calls/${chatId}/answer`).on('value', async (snap) => {
          const ans = snap.val(); if (ans) await rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(ans));
        });
        db.ref(`calls/${chatId}/candidates`).on('child_added', async (snap) => {
          const c = snap.val(); try { await rtcPeerConnection.addIceCandidate(new RTCIceCandidate(c)); } catch (_) {}
        });
        callStatus.textContent = 'Ringing...'; callStatus.className = 'status info';
      } catch (e) { showStatus(callStatus, `Call error: ${e.message}`, 'error'); }
    }

    async function endCall() {
      const chatId = currentChat ? getChatId(currentChat.id, currentChat.type) : null;
      try { rtcPeerConnection?.close(); } catch {}
      rtcPeerConnection = null;
      rtcLocalStream?.getTracks().forEach(t => t.stop()); rtcLocalStream = null;
      rtcRemoteStream = null; localVideo.srcObject = null; remoteVideo.srcObject = null;
      if (chatId) await db.ref(`calls/${chatId}`).remove();
      callModal.classList.remove('active');
    }

    function toggleMic() { setMic(!isMicEnabled()); }
    function isMicEnabled() { return rtcLocalStream?.getAudioTracks().every(t => t.enabled); }
    function setMic(on) { rtcLocalStream?.getAudioTracks().forEach(t => t.enabled = on); toggleMicBtn.innerHTML = on ? '<i class="fas fa-microphone"></i> Mic' : '<i class="fas fa-microphone-slash"></i> Mic'; }
    function toggleCam() { rtcLocalStream?.getVideoTracks().forEach(t => t.enabled = !t.enabled); }
    
    async function toggleScreenShare() {
      if (!rtcPeerConnection) return;
      if (!isScreenSharing) {
        try {
          const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          const sender = rtcPeerConnection.getSenders().find(s => s.track?.kind === 'video');
          await sender?.replaceTrack(screenStream.getVideoTracks()[0]);
          isScreenSharing = true;
          toggleScreenBtn.innerHTML = '<i class="fas fa-desktop"></i> Stop';
        } catch (e) { showStatus(callStatus, `Screen share error: ${e.message}`, 'error'); }
      } else {
        const cam = (await navigator.mediaDevices.getUserMedia({ video: isVideoCall, audio: true })).getVideoTracks()[0];
        const sender = rtcPeerConnection.getSenders().find(s => s.track?.kind === 'video');
        await sender?.replaceTrack(cam);
        isScreenSharing = false;
        toggleScreenBtn.innerHTML = '<i class="fas fa-desktop"></i> Screen';
      }
    }

    function togglePTT() {
      const active = pttToggleBtn.dataset.active === 'true';
      pttToggleBtn.dataset.active = (!active).toString();
      pttToggleBtn.innerHTML = active ? '<i class="fas fa-microphone-slash"></i>' : '<i class="fas fa-microphone"></i>';
      showStatus(chatStatus, `Push-to-talk ${!active ? 'enabled' : 'disabled'}. Hold Space to talk.`, 'info');
    }

    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyD9uzP781-TlDSC9fILQX8M-Xa7Ely_rZc",
      authDomain: "chayt-41951.firebaseapp.com",
      projectId: "chayt-41951",
      storageBucket: "chayt-41951.appspot.com",
      messagingSenderId: "841659925542",
      appId: "1:841659925542:web:ba7751ee2a97b5fcf452e7",
      databaseURL: "https://chayt-41951-default-rtdb.firebaseio.com"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const storage = firebase.storage();
    const auth = firebase.auth();

    // DOM Elements
    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    const loginTab = document.getElementById('login-tab');
    const registerTab = document.getElementById('register-tab');
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    const loginBtn = document.getElementById('login-btn');
    const registerBtn = document.getElementById('register-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const loginStatus = document.getElementById('login-status');
    const registerStatus = document.getElementById('register-status');
    const chatStatus = document.getElementById('chat-status');
    const messagesContainer = document.getElementById('messages');
    const messageInput = document.getElementById('message');
    const uploadInput = document.getElementById('upload');
    const sendTextBtn = document.getElementById('send-text-btn');
    const sendImageBtn = document.getElementById('send-image-btn');
    const friendsList = document.getElementById('friends-list');
    const addFriendBtn = document.getElementById('add-friend-btn');
    const friendRequestsBtn = document.getElementById('friend-requests-btn');
    const createGroupBtn = document.getElementById('create-group-btn');
    const requestBadge = document.getElementById('request-badge');
    const addFriendModal = document.getElementById('add-friend-modal');
    const closeAddFriend = document.getElementById('close-add-friend');
    const sendRequestBtn = document.getElementById('send-request-btn');
    const friendUsernameInput = document.getElementById('friend-username');
    const friendStatus = document.getElementById('friend-status');
    const requestsModal = document.getElementById('requests-modal');
    const closeRequests = document.getElementById('close-requests');
    const requestsList = document.getElementById('requests-list');
    const requestsStatus = document.getElementById('requests-status');
    const createGroupModal = document.getElementById('create-group-modal');
    const closeCreateGroup = document.getElementById('close-create-group');
    const createGroupConfirmBtn = document.getElementById('create-group-confirm-btn');
    const groupNameInput = document.getElementById('group-name');
    const friendsToAdd = document.getElementById('friends-to-add');
    const groupStatus = document.getElementById('group-status');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettings = document.getElementById('close-settings');
    const saveSettingsBtn = document.getElementById('save-settings-btn');
    const settingsStatus = document.getElementById('settings-status');
    const chatTitle = document.getElementById('chat-title');
    const chatActions = document.getElementById('chat-actions');
    const addFriendsToGroupBtn = document.getElementById('add-friends-to-group-btn');
    const leaveGroupBtn = document.getElementById('leave-group-btn');
    const kickMemberBtn = document.getElementById('kick-member-btn');
    const addFriendsToGroupModal = document.getElementById('add-friends-to-group-modal');
    const closeAddFriendsToGroup = document.getElementById('close-add-friends-to-group');
    const addFriendsToGroupConfirmBtn = document.getElementById('add-friends-to-group-confirm-btn');
    const friendsToAddToGroup = document.getElementById('friends-to-add-to-group');
    const addFriendsStatus = document.getElementById('add-friends-status');
    const imagePreview = document.getElementById('image-preview');
    const removeImageBtn = document.getElementById('remove-image-btn');
    const profileView = document.getElementById('profile-view');
    const profileEditForm = document.getElementById('profile-edit-form');
    const profileAvatar = document.getElementById('profile-avatar');
    const profileAvatarText = document.getElementById('profile-avatar-text');
    const profileAvatarImg = document.getElementById('profile-avatar-img');
    const profileName = document.getElementById('profile-name');
    const profileDescription = document.getElementById('profile-description');
    const profileEditBtn = document.getElementById('profile-edit-btn');
    const profilePictureUpload = document.getElementById('profile-picture-upload');
    const profileDescriptionInput = document.getElementById('profile-description-input');
    const saveProfileBtn = document.getElementById('save-profile-btn');
    const cancelProfileEditBtn = document.getElementById('cancel-profile-edit-btn');
    const profileViewModal = document.getElementById('profile-view-modal');
    const closeProfileView = document.getElementById('close-profile-view');
    const profileModalTitle = document.getElementById('profile-modal-title');
    const profileModalAvatar = document.getElementById('profile-modal-avatar');
    const profileModalAvatarText = document.getElementById('profile-modal-avatar-text');
    const profileModalAvatarImg = document.getElementById('profile-modal-avatar-img');
    const profileModalName = document.getElementById('profile-modal-name');
    const profileModalDescription = document.getElementById('profile-modal-description');
    const toggleLoginPassword = document.getElementById('toggle-login-password');
    const toggleRegisterPassword = document.getElementById('toggle-register-password');
    const toggleConfirmPassword = document.getElementById('toggle-confirm-password');
    const chatSearchInput = document.getElementById('chat-search');
    const pinnedMessagesContainer = document.getElementById('pinned-messages-container');
    const pinnedMessagesList = document.getElementById('pinned-messages');
    const typingIndicator = document.getElementById('typing-indicator');
    const typingText = document.getElementById('typing-text');
    const appearanceTab = document.getElementById('appearance-tab');
    const blockedUsersTab = document.getElementById('blocked-users-tab');
    const appearanceSettings = document.getElementById('appearance-settings');
    const blockedUsersSettings = document.getElementById('blocked-users-settings');
    const blockedUsersList = document.getElementById('blocked-users-list');
    const blockedUsersStatus = document.getElementById('blocked-users-status');
    const blockUserBtn = document.getElementById('block-user-btn');
    const reactionPickerModal = document.getElementById('reaction-picker-modal');
    const closeReactionPicker = document.getElementById('close-reaction-picker');
    const contextMenu = document.getElementById('context-menu');
    // Newly added elements
    const voiceCallBtn = document.getElementById('voice-call-btn');
    const videoCallBtn = document.getElementById('video-call-btn');
    const screenShareBtn = document.getElementById('screen-share-btn');
    const pttToggleBtn = document.getElementById('ptt-toggle-btn');
    const callModal = document.getElementById('call-modal');
    const closeCallModal = document.getElementById('close-call-modal');
    const callStatus = document.getElementById('call-status');
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const toggleMicBtn = document.getElementById('toggle-mic-btn');
    const toggleCamBtn = document.getElementById('toggle-cam-btn');
    const toggleScreenBtn = document.getElementById('toggle-screen-btn');
    const endCallBtn = document.getElementById('end-call-btn');
    const fileUpload = document.getElementById('file-upload');
    const recordVoiceBtn = document.getElementById('record-voice-btn');
    const scheduleTimeInput = document.getElementById('schedule-time');
    const scheduleSendBtn = document.getElementById('schedule-send-btn');
    const ttlSelect = document.getElementById('ttl-select');
    const emojiGifBtn = document.getElementById('emoji-gif-btn');
    const gamesBtn = document.getElementById('games-btn');
    const pollsBtn = document.getElementById('polls-btn');
    const drawBtn = document.getElementById('draw-btn');
    const whiteboardBtn = document.getElementById('whiteboard-btn');
    const emojiGifModal = document.getElementById('emoji-gif-modal');
    const closeEmojiGif = document.getElementById('close-emoji-gif');
    const gifSearch = document.getElementById('gif-search');
    const gifSearchBtn = document.getElementById('gif-search-btn');
    const gifResults = document.getElementById('gif-results');
    const gamesModal = document.getElementById('games-modal');
    const closeGames = document.getElementById('close-games');
    const gameContainer = document.getElementById('game-container');
    const pollsModalEl = document.getElementById('polls-modal');
    const closePolls = document.getElementById('close-polls');
    const pollQuestion = document.getElementById('poll-question');
    const createPollBtn = document.getElementById('create-poll-btn');
    const addPollOptionBtn = document.getElementById('add-poll-option');
    const drawModalEl = document.getElementById('draw-modal');
    const closeDraw = document.getElementById('close-draw');
    const drawCanvas = document.getElementById('draw-canvas');
    const drawColor = document.getElementById('draw-color');
    const drawSize = document.getElementById('draw-size');
    const drawClear = document.getElementById('draw-clear');
    const drawSend = document.getElementById('draw-send');
    const whiteboardModalEl = document.getElementById('whiteboard-modal');
    const closeWhiteboard = document.getElementById('close-whiteboard');
    const whiteboardCanvas = document.getElementById('whiteboard-canvas');
    const whiteboardColor = document.getElementById('whiteboard-color');
    const whiteboardSize = document.getElementById('whiteboard-size');
    const whiteboardClear = document.getElementById('whiteboard-clear');

    const statusBtn = document.getElementById('status-updates-btn');
    const statusModal = document.getElementById('status-modal');
    const closeStatus = document.getElementById('close-status');
    const postStatusBtn = document.getElementById('post-status-btn');
    const musicBtn = document.getElementById('music-share-btn');
    const musicModal = document.getElementById('music-modal');
    const closeMusic = document.getElementById('close-music');
    const shareMusicBtn = document.getElementById('share-music-btn');
    const messageSearchBtn = document.getElementById('message-search-btn');
    const searchModal = document.getElementById('search-modal');
    const closeSearch = document.getElementById('close-search');
    const searchQuery = document.getElementById('search-query');
    const chatThemeBtn = document.getElementById('chat-theme-btn');
    const securityTab = document.getElementById('security-tab');
    const notesBtn = document.getElementById('notes-btn');
    const notesModal = document.getElementById('notes-modal');
    const closeNotes = document.getElementById('close-notes');
    const saveNoteBtn = document.getElementById('save-note-btn');
    const newNoteBtn = document.getElementById('new-note-btn');
    const noteTitle = document.getElementById('note-title');
    const noteContent = document.getElementById('note-content');
    const notesList = document.getElementById('notes-list');

    // Current User and App State
    let currentUser = null;
    let currentChat = null;
    let friends = [];
    let pendingRequests = [];
    let groups = [];
    let currentGroupMembers = [];
    let selectedImage = null;
    let profilePictureFile = null;
    let chatActivity = {}; // Tracks last activity time for each chat
    let messageDrafts = {}; // Stores unsent message drafts
    let typingTimeout = null;
    let currentlyViewingProfile = null;
    let selectedMessageForReaction = null;
    let messageSendLock = false;
    let hiddenChats = JSON.parse(localStorage.getItem('hiddenChats') || '{}');

    // WebRTC state
    let rtcPeerConnection = null;
    let rtcLocalStream = null;
    let rtcRemoteStream = null;
    let isVideoCall = false;
    let isScreenSharing = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let pttActive = false;

    // Encryption/Decryption helpers (simple XOR for demo)
    function maybeEncrypt(text) {
      // Simple XOR encryption for demo purposes
      const key = 'chayt2024';
      let result = '';
      for (let i = 0; i < text.length; i++) {
        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
      }
      return btoa(result);
    }

    function maybeDecrypt(text) {
      try {
        const key = 'chayt2024';
        const decoded = atob(text);
        let result = '';
        for (let i = 0; i < decoded.length; i++) {
          result += String.fromCharCode(decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length));
        }
        return result;
      } catch (e) {
        return text; // Return original if decryption fails
      }
    }

    // Cycle chat theme
    function cycleChatTheme() {
      const themes = ['default', 'dark', 'light', 'colorful'];
      const currentTheme = localStorage.getItem('chatTheme') || 'default';
      const currentIndex = themes.indexOf(currentTheme);
      const nextIndex = (currentIndex + 1) % themes.length;
      const nextTheme = themes[nextIndex];
      
      localStorage.setItem('chatTheme', nextTheme);
      applyChatTheme(nextTheme);
      showStatus(chatStatus, `Theme changed to ${nextTheme}`, 'success');
    }

    function applyChatTheme(theme) {
      const messagesContainer = document.getElementById('messages');
      messagesContainer.className = `messages-container theme-${theme}`;
    }

    // Save security settings
    function saveSecurity() {
      const passphrase = document.getElementById('e2ee-passphrase').value;
      if (passphrase) {
        localStorage.setItem('e2eePassphrase', passphrase);
        showStatus(document.getElementById('security-status'), 'Security settings saved', 'success');
      }
    }

    // Notes functionality
    function loadNotes() {
      const notes = JSON.parse(localStorage.getItem(`notes_${currentUser.username}`) || '[]');
      notesList.innerHTML = '';
      
      notes.forEach((note, index) => {
        const noteEl = document.createElement('div');
        noteEl.style.cssText = `
          padding: 12px;
          background: rgba(255,255,255,0.05);
          border-radius: 8px;
          margin-bottom: 8px;
          cursor: pointer;
          border-left: 3px solid var(--accent);
        `;
        noteEl.innerHTML = `
          <div style="font-weight: bold; margin-bottom: 4px;">${note.title}</div>
          <div style="font-size: 12px; opacity: 0.8; margin-bottom: 8px;">${new Date(note.timestamp).toLocaleString()}</div>
          <div style="font-size: 13px; opacity: 0.9;">${note.content.substring(0, 100)}${note.content.length > 100 ? '...' : ''}</div>
          <div style="margin-top: 8px;">
            <button onclick="editNote(${index})" style="padding: 4px 8px; font-size: 11px; margin-right: 4px;">Edit</button>
            <button onclick="deleteNote(${index})" style="padding: 4px 8px; font-size: 11px; background: var(--error);">Delete</button>
          </div>
        `;
        notesList.appendChild(noteEl);
      });
    }

    function saveNote() {
      const title = noteTitle.value.trim();
      const content = noteContent.value.trim();
      
      if (!title || !content) {
        showStatus(chatStatus, 'Please fill in both title and content', 'error');
        return;
      }
      
      const notes = JSON.parse(localStorage.getItem(`notes_${currentUser.username}`) || '[]');
      const currentNoteIndex = parseInt(noteTitle.dataset.noteIndex || '-1');
      
      if (currentNoteIndex >= 0) {
        // Update existing note
        notes[currentNoteIndex] = { title, content, timestamp: Date.now() };
      } else {
        // Add new note
        notes.push({ title, content, timestamp: Date.now() });
      }
      
      localStorage.setItem(`notes_${currentUser.username}`, JSON.stringify(notes));
      loadNotes();
      
      // Clear form
      noteTitle.value = '';
      noteContent.value = '';
      delete noteTitle.dataset.noteIndex;
      
      showStatus(chatStatus, 'Note saved successfully!', 'success');
    }

    function createNewNote() {
      noteTitle.value = '';
      noteContent.value = '';
      delete noteTitle.dataset.noteIndex;
      noteTitle.focus();
    }

    function editNote(index) {
      const notes = JSON.parse(localStorage.getItem(`notes_${currentUser.username}`) || '[]');
      const note = notes[index];
      
      if (note) {
        noteTitle.value = note.title;
        noteContent.value = note.content;
        noteTitle.dataset.noteIndex = index;
        noteTitle.focus();
      }
    }

    function deleteNote(index) {
      if (confirm('Are you sure you want to delete this note?')) {
        const notes = JSON.parse(localStorage.getItem(`notes_${currentUser.username}`) || '[]');
        notes.splice(index, 1);
        localStorage.setItem(`notes_${currentUser.username}`, JSON.stringify(notes));
        loadNotes();
        showStatus(chatStatus, 'Note deleted successfully!', 'success');
      }
    }

    // Initialize the app
    function init() {
      ensureAuth().then(() => {
        checkAuth();
        setupEventListeners();
        setupTextareaAutoResize();
        document.addEventListener('click', closeContextMenu);
        
        // Apply saved chat theme
        const savedTheme = localStorage.getItem('chatTheme') || 'default';
        applyChatTheme(savedTheme);
        
        // Load saved settings
        loadSavedSettings();
      });
    }

    // Ensure we have an authenticated session (anonymous) so Realtime DB rules that require auth will pass
    function ensureAuth() {
      return new Promise((resolve) => {
        try {
          auth.onAuthStateChanged((user) => {
            if (user) return resolve();
            auth.signInAnonymously().then(() => resolve()).catch(() => resolve());
          });
        } catch (_) { resolve(); }
      });
    }

    // Set up event listeners
    function setupEventListeners() {
      // Auth tabs
      loginTab.addEventListener('click', () => {
        loginTab.classList.add('active');
        registerTab.classList.remove('active');
        loginForm.style.display = 'flex';
        registerForm.style.display = 'none';
      });

      registerTab.addEventListener('click', () => {
        registerTab.classList.add('active');
        loginTab.classList.remove('active');
        registerForm.style.display = 'flex';
        loginForm.style.display = 'none';
      });

      // Settings tabs
      appearanceTab.addEventListener('click', () => {
        appearanceTab.classList.add('active');
        blockedUsersTab.classList.remove('active');
        if (securityTab) securityTab.classList.remove('active');
        document.getElementById('patchnotes-tab').classList.remove('active');
        appearanceSettings.style.display = 'block';
        blockedUsersSettings.style.display = 'none';
        if (document.getElementById('security-settings')) {
          document.getElementById('security-settings').style.display = 'none';
        }
        document.getElementById('patchnotes-settings').style.display = 'none';
      });

      blockedUsersTab.addEventListener('click', () => {
        blockedUsersTab.classList.add('active');
        appearanceTab.classList.remove('active');
        if (securityTab) securityTab.classList.remove('active');
        document.getElementById('patchnotes-tab').classList.remove('active');
        blockedUsersSettings.style.display = 'block';
        appearanceSettings.style.display = 'none';
        if (document.getElementById('security-settings')) {
          document.getElementById('security-settings').style.display = 'none';
        }
        document.getElementById('patchnotes-settings').style.display = 'none';
        loadBlockedUsers();
      });
      // Security tab wiring if present
      if (securityTab) {
        securityTab.addEventListener('click', () => {
          securityTab.classList.add('active');
          appearanceTab.classList.remove('active');
          blockedUsersTab.classList.remove('active');
          document.getElementById('patchnotes-tab').classList.remove('active');
          document.getElementById('security-settings').style.display = 'block';
          appearanceSettings.style.display = 'none';
          blockedUsersSettings.style.display = 'none';
          document.getElementById('patchnotes-settings').style.display = 'none';
        });
      }

      // Patch Notes tab
      const patchnotesTab = document.getElementById('patchnotes-tab');
      if (patchnotesTab) {
        patchnotesTab.addEventListener('click', () => {
          patchnotesTab.classList.add('active');
          appearanceTab.classList.remove('active');
          blockedUsersTab.classList.remove('active');
          if (securityTab) securityTab.classList.remove('active');
          document.getElementById('patchnotes-settings').style.display = 'block';
          appearanceSettings.style.display = 'none';
          blockedUsersSettings.style.display = 'none';
          if (document.getElementById('security-settings')) {
            document.getElementById('security-settings').style.display = 'none';
          }
        });
      }

      // Auth buttons
      registerBtn.addEventListener('click', registerUser);
      loginBtn.addEventListener('click', loginUser);
      logoutBtn.addEventListener('click', logoutUser);

      // Password visibility toggles
      toggleLoginPassword.addEventListener('click', function() {
        togglePasswordVisibility('login-password', this);
      });

      toggleRegisterPassword.addEventListener('click', function() {
        togglePasswordVisibility('register-password', this);
      });

      toggleConfirmPassword.addEventListener('click', function() {
        togglePasswordVisibility('confirm-password', this);
      });

      // Chat buttons
      messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendText();
        }
      });
      
      messageInput.addEventListener('input', () => {
        // Save draft
        if (currentChat) {
          messageDrafts[currentChat.id] = messageInput.value;
        }
        
        
        // Show typing indicator
        if (currentChat && currentChat.type === 'friend') {
          const chatId = getChatId(currentChat.id, currentChat.type);
          db.ref(`typing/${chatId}/${currentUser.username}`).set(true);
          clearTimeout(typingTimeout);
          typingTimeout = setTimeout(() => {
            db.ref(`typing/${chatId}/${currentUser.username}`).remove();
          }, 2000);
        }
      });
      
      sendTextBtn.addEventListener('click', sendText);
      sendImageBtn.addEventListener('click', uploadImage);
      uploadInput.addEventListener('change', handleImageUpload);
      removeImageBtn.addEventListener('click', removeImage);
      chatSearchInput.addEventListener('input', searchChats);

      // Friend buttons
      addFriendBtn.addEventListener('click', () => {
        addFriendModal.classList.add('active');
      });
      closeAddFriend.addEventListener('click', () => {
        addFriendModal.classList.remove('active');
      });
      sendRequestBtn.addEventListener('click', sendFriendRequest);
      friendRequestsBtn.addEventListener('click', () => {
        requestsModal.classList.add('active');
        loadFriendRequests();
      });
      closeRequests.addEventListener('click', () => {
        requestsModal.classList.remove('active');
      });

      // Group buttons
      createGroupBtn.addEventListener('click', () => {
        createGroupModal.classList.add('active');
        loadFriendsForGroup();
      });
      closeCreateGroup.addEventListener('click', () => {
        createGroupModal.classList.remove('active');
      });
      createGroupConfirmBtn.addEventListener('click', createGroup);
      addFriendsToGroupBtn.addEventListener('click', () => {
        addFriendsToGroupModal.classList.add('active');
        loadFriendsToAddToGroup();
      });
      closeAddFriendsToGroup.addEventListener('click', () => {
        addFriendsToGroupModal.classList.remove('active');
      });
      addFriendsToGroupConfirmBtn.addEventListener('click', addFriendsToGroup);
      leaveGroupBtn.addEventListener('click', leaveGroup);
      kickMemberBtn.addEventListener('click', kickMember);

      // Settings buttons
      settingsBtn.addEventListener('click', () => {
        settingsModal.classList.add('active');
        appearanceTab.click();
      });
      closeSettings.addEventListener('click', () => {
        settingsModal.classList.remove('active');
      });

      // Patch Notes button
      const patchnotesBtn = document.getElementById('patchnotes-btn');
      if (patchnotesBtn) {
        patchnotesBtn.addEventListener('click', () => {
          settingsModal.classList.add('active');
          document.getElementById('patchnotes-tab').click();
        });
      }
      saveSettingsBtn.addEventListener('click', saveSettings);
      const saveSecurityBtnEl = document.getElementById('save-security-btn');
      if (saveSecurityBtnEl) saveSecurityBtnEl.addEventListener('click', saveSecurity);

      // Theme selection
      document.querySelectorAll('.theme-option').forEach(option => {
        option.addEventListener('click', () => {
          document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
          option.classList.add('active');
          const theme = option.dataset.theme;
          applyTheme(theme);
        });
      });

      // Profile buttons
      profileEditBtn.addEventListener('click', () => {
        profileView.style.display = 'none';
        profileEditForm.style.display = 'flex';
      });
      cancelProfileEditBtn.addEventListener('click', () => {
        profileView.style.display = 'flex';
        profileEditForm.style.display = 'none';
      });
      saveProfileBtn.addEventListener('click', saveProfile);
      profilePictureUpload.addEventListener('change', handleProfilePictureUpload);
      closeProfileView.addEventListener('click', () => {
        profileViewModal.classList.remove('active');
      });
      blockUserBtn.addEventListener('click', blockUser);

      // Background options
      document.querySelectorAll('.bg-option').forEach(option => {
        option.addEventListener('click', () => {
          document.querySelectorAll('.bg-option').forEach(opt => {
            opt.classList.remove('active');
          });
          option.classList.add('active');
        });
      });

      // Reaction picker
      closeReactionPicker.addEventListener('click', () => {
        reactionPickerModal.classList.remove('active');
      });
      
      document.querySelectorAll('.reaction-option').forEach(option => {
        option.addEventListener('click', () => {
          if (selectedMessageForReaction) {
            addReaction(selectedMessageForReaction, option.dataset.reaction);
            reactionPickerModal.classList.remove('active');
          }
        });
      });

      // Context menu for friend items
      document.addEventListener('contextmenu', (e) => {
        const friendItem = e.target.closest('.friend-item[data-username], .friend-item[data-group]');
        if (friendItem) {
          e.preventDefault();
          showContextMenu(e, friendItem.dataset.username || friendItem.dataset.group, 
                         friendItem.dataset.username ? 'friend' : 'group');
        }
      });

      // Calls
      if (voiceCallBtn) voiceCallBtn.addEventListener('click', () => startCall(false));
      if (videoCallBtn) videoCallBtn.addEventListener('click', () => startCall(true));
      if (closeCallModal) closeCallModal.addEventListener('click', endCall);
      if (endCallBtn) endCallBtn.addEventListener('click', endCall);
      if (toggleMicBtn) toggleMicBtn.addEventListener('click', toggleMic);
      if (toggleCamBtn) toggleCamBtn.addEventListener('click', toggleCam);
      if (toggleScreenBtn) toggleScreenBtn.addEventListener('click', toggleScreenShare);
      if (pttToggleBtn) pttToggleBtn.addEventListener('click', togglePTT);
      document.addEventListener('keydown', (e) => { if (e.code === 'Space' && pttToggleBtn && pttToggleBtn.dataset.active === 'true') setMic(true); });
      document.addEventListener('keyup', (e) => { if (e.code === 'Space' && pttToggleBtn && pttToggleBtn.dataset.active === 'true') setMic(false); });

      // Files
      if (fileUpload) fileUpload.addEventListener('change', handleFileUpload);

      // Voice messages
      if (recordVoiceBtn) recordVoiceBtn.addEventListener('click', handleVoiceRecord);

      // Scheduling
      if (scheduleSendBtn) scheduleSendBtn.addEventListener('click', scheduleMessage);

      // New input controls
      const attachBtn = document.getElementById('attach-btn');
      const moreOptionsBtn = document.getElementById('more-options-btn');
      const moreOptionsDropdown = document.getElementById('more-options-dropdown');
      
      if (attachBtn) attachBtn.addEventListener('click', () => fileUpload.click());
      if (moreOptionsBtn) moreOptionsBtn.addEventListener('click', () => {
        moreOptionsDropdown.style.display = moreOptionsDropdown.style.display === 'none' ? 'block' : 'none';
      });
      
      // More options dropdown
      document.addEventListener('click', (e) => {
        if (!moreOptionsDropdown.contains(e.target) && !moreOptionsBtn.contains(e.target)) {
          moreOptionsDropdown.style.display = 'none';
        }
      });
      
      document.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          moreOptionsDropdown.style.display = 'none';
          
          switch(action) {
            case 'image': upload.click(); break;
            case 'file': fileUpload.click(); break;
            case 'schedule': showScheduleModal(); break;
            case 'ttl': showTTLModal(); break;
            case 'games': gamesModal.classList.add('active'); break;
            case 'polls': pollsModalEl.classList.add('active'); break;
            case 'draw': drawModalEl.classList.add('active'); break;
            case 'whiteboard': whiteboardModalEl.classList.add('active'); break;
          }
        });
      });
      
      // Emoji/GIF
      if (emojiGifBtn) emojiGifBtn.addEventListener('click', () => emojiGifModal.classList.add('active'));
      if (closeEmojiGif) closeEmojiGif.addEventListener('click', () => emojiGifModal.classList.remove('active'));
      if (gifSearchBtn) gifSearchBtn.addEventListener('click', searchGifs);

      // Games
      if (gamesBtn) gamesBtn.addEventListener('click', () => gamesModal.classList.add('active'));
      if (closeGames) closeGames.addEventListener('click', () => gamesModal.classList.remove('active'));
      document.querySelectorAll('.game-launch').forEach(btn => btn.addEventListener('click', () => launchGame(btn.dataset.game)));


      // Polls
      if (pollsBtn) pollsBtn.addEventListener('click', () => pollsModalEl.classList.add('active'));
      if (closePolls) closePolls.addEventListener('click', () => pollsModalEl.classList.remove('active'));
      if (addPollOptionBtn) addPollOptionBtn.addEventListener('click', addPollOption);
      if (createPollBtn) createPollBtn.addEventListener('click', createPoll);

      // Drawing
      if (drawBtn) drawBtn.addEventListener('click', () => drawModalEl.classList.add('active'));
      if (closeDraw) closeDraw.addEventListener('click', () => drawModalEl.classList.remove('active'));
      if (drawCanvas) setupDrawing(drawCanvas, drawColor, drawSize);
      if (drawClear) drawClear.addEventListener('click', () => clearCanvas(drawCanvas));
      if (drawSend) drawSend.addEventListener('click', sendDrawing);

      // Whiteboard
      if (whiteboardBtn) whiteboardBtn.addEventListener('click', () => whiteboardModalEl.classList.add('active'));
      if (closeWhiteboard) closeWhiteboard.addEventListener('click', () => whiteboardModalEl.classList.remove('active'));
      setupWhiteboard();



      // Status updates
      if (statusBtn) statusBtn.addEventListener('click', () => { statusModal.classList.add('active'); loadStatusFeed(); });
      if (closeStatus) closeStatus.addEventListener('click', () => statusModal.classList.remove('active'));
      if (postStatusBtn) postStatusBtn.addEventListener('click', postStatus);

      // Music share
      if (musicBtn) musicBtn.addEventListener('click', () => musicModal.classList.add('active'));
      if (closeMusic) closeMusic.addEventListener('click', () => musicModal.classList.remove('active'));
      if (shareMusicBtn) shareMusicBtn.addEventListener('click', shareMusic);

      // Message search
      if (messageSearchBtn) messageSearchBtn.addEventListener('click', () => searchModal.classList.add('active'));
      if (closeSearch) closeSearch.addEventListener('click', () => searchModal.classList.remove('active'));
      if (searchQuery) searchQuery.addEventListener('input', runMessageSearch);

      // Chat theme per-chat
      if (chatThemeBtn) chatThemeBtn.addEventListener('click', () => cycleChatTheme());

      // Notes functionality
      if (notesBtn) notesBtn.addEventListener('click', () => {
        notesModal.classList.add('active');
        loadNotes();
      });
      if (closeNotes) closeNotes.addEventListener('click', () => notesModal.classList.remove('active'));
      if (saveNoteBtn) saveNoteBtn.addEventListener('click', saveNote);
      if (newNoteBtn) newNoteBtn.addEventListener('click', createNewNote);
    }

    // Get consistent chat ID for friend chats
    function getChatId(id, type) {
      if (type === 'friend') {
        const users = [currentUser.username, id].sort();
        return users.join('_');
      }
      return id;
    }

    // Show context menu
    function showContextMenu(e, chatId, chatType) {
      closeContextMenu();

      contextMenu.innerHTML = `
        <div class="context-menu-item" data-action="toggle-visibility" data-chat="${chatId}">
          ${hiddenChats[chatId] ? 'Show Chat' : 'Hide Chat'}
        </div>
      `;

      contextMenu.style.display = 'block';
      contextMenu.style.left = `${e.pageX}px`;
      contextMenu.style.top = `${e.pageY}px`;

      contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
        item.addEventListener('click', () => {
          if (item.dataset.action === 'toggle-visibility') {
            toggleChatVisibility(item.dataset.chat);
          }
          closeContextMenu();
        });
      });
    }

    // Close context menu
    function closeContextMenu() {
      contextMenu.style.display = 'none';
    }

    // Toggle chat visibility
    function toggleChatVisibility(chatId) {
      hiddenChats[chatId] = !hiddenChats[chatId];
      localStorage.setItem('hiddenChats', JSON.stringify(hiddenChats));
      
      const chatItem = document.querySelector(`.friend-item[data-username="${chatId}"], .friend-item[data-group="${chatId}"]`);
      if (chatItem) {
        chatItem.classList.toggle('hidden-chat', hiddenChats[chatId]);
      }
    }

    // Toggle password visibility
    function togglePasswordVisibility(inputId, icon) {
      const input = document.getElementById(inputId);
      if (input.type === 'password') {
        input.type = 'text';
        icon.classList.remove('fa-eye');
        icon.classList.add('fa-eye-slash');
      } else {
        input.type = 'password';
        icon.classList.remove('fa-eye-slash');
        icon.classList.add('fa-eye');
      }
    }

    // Set up textarea auto-resize
    function setupTextareaAutoResize() {
      messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
      });
    }

    // Show status message
    function showStatus(element, message, type) {
      element.textContent = message;
      element.className = `status ${type}`;
      
      if (type !== 'loading') {
        setTimeout(() => {
          element.textContent = '';
          element.className = 'status';
        }, 3000);
      }
    }

    // Format timestamp
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Register new user with Firebase
    async function registerUser() {
      const username = document.getElementById('register-username').value.trim();
      const password = document.getElementById('register-password').value.trim();
      const confirmPassword = document.getElementById('confirm-password').value.trim();

      // Validation
      if (!username || !password || !confirmPassword) {
        showStatus(registerStatus, 'All fields are required', 'error');
        return;
      }

      if (password !== confirmPassword) {
        showStatus(registerStatus, 'Passwords do not match', 'error');
        return;
      }

      if (password.length < 6) {
        showStatus(registerStatus, 'Password must be at least 6 characters', 'error');
        return;
      }

      showStatus(registerStatus, 'Creating account...', 'loading');
      registerBtn.disabled = true;

      try {
        // Ensure anon auth present for database security rules
        await ensureAuth();
        // Check if username already exists
        const snapshot = await db.ref(`users/${username}`).once('value');
        if (snapshot.exists()) {
          throw new Error('Username already exists');
        }
        
        // Create user in database
        await db.ref(`users/${username}`).set({
          username,
          password, // Note: In production, you should hash passwords
          createdAt: Date.now(),
          friends: [],
          friendRequests: [],
          groups: {},
          blockedUsers: [],
          profile: {
            description: '',
            avatarUrl: ''
          },
          lastSeen: Date.now()
        });

        showStatus(registerStatus, 'Account created successfully!', 'success');
        
        // Clear form
        document.getElementById('register-username').value = '';
        document.getElementById('register-password').value = '';
        document.getElementById('confirm-password').value = '';
        
        // Switch to login tab
        setTimeout(() => {
          loginTab.click();
        }, 1500);
      } catch (error) {
        console.error('Registration error:', error);
        showStatus(registerStatus, `Error: ${error.message}`, 'error');
      } finally {
        registerBtn.disabled = false;
      }
    }

    // Login user with Firebase
    async function loginUser() {
      const username = document.getElementById('login-username').value.trim();
      const password = document.getElementById('login-password').value.trim();

      if (!username || !password) {
        showStatus(loginStatus, 'Username and password are required', 'error');
        return;
      }

      // Special handling for Yug
      if (username === 'Yug' && password === 'Hiren611') {
        // Check if Yug exists, create if not
        const snapshot = await db.ref(`users/Yug`).once('value');
        if (!snapshot.exists()) {
          await db.ref(`users/Yug`).set({
            username: 'Yug',
            password: 'Hiren611',
            createdAt: Date.now(),
            friends: [],
            friendRequests: [],
            groups: {},
            blockedUsers: [],
            profile: {
              description: 'Owner of Chayt',
              avatarUrl: ''
            },
            lastSeen: Date.now()
          });
        }
      }

      showStatus(loginStatus, 'Signing in...', 'loading');
      loginBtn.disabled = true;

      try {
        await ensureAuth();
        // Get user from Firebase
        const snapshot = await db.ref(`users/${username}`).once('value');
        const user = snapshot.val();
        
        if (!user || user.password !== password) {
          throw new Error('Invalid username or password');
        }

        currentUser = {
          uid: user.username,
          username: user.username,
          friends: user.friends || [],
          friendRequests: user.friendRequests || [],
          groups: user.groups ? Object.keys(user.groups) : [],
          blockedUsers: user.blockedUsers || [],
          profile: user.profile || { description: '', avatarUrl: '' }
        };

        // Save to localStorage for persistent login
        localStorage.setItem('currentUser', JSON.stringify({
          username: currentUser.username,
          password: password, // Note: In production, use a more secure method
          lastLogin: Date.now()
        }));

        // Update UI
        profileName.textContent = currentUser.username;
        profileAvatarText.textContent = currentUser.username.charAt(0).toUpperCase();
        
        // Load profile picture if exists
        if (currentUser.profile.avatarUrl) {
          profileAvatarImg.src = currentUser.profile.avatarUrl;
          profileAvatarImg.style.display = 'block';
          profileAvatarText.style.display = 'none';
        } else {
          profileAvatarImg.style.display = 'none';
          profileAvatarText.style.display = 'block';
        }
        
        // Load profile description
        if (currentUser.profile.description) {
          profileDescription.textContent = currentUser.profile.description;
        }

        showStatus(loginStatus, 'Login successful!', 'success');
        
        // Switch to chat interface
        setTimeout(() => {
          authContainer.style.display = 'none';
          appContainer.style.display = 'flex';
          messageInput.focus();
          loadFriends();
          loadFriendRequests();
          loadGroups();
          
          // Show welcome message
          showStatus(chatStatus, `Welcome back, ${currentUser.username}! ðŸŽ‰`, 'success');
          
          // Add welcome message to general chat if it's the first time
          const isFirstTime = !localStorage.getItem(`welcome_${currentUser.username}`);
          if (isFirstTime) {
            localStorage.setItem(`welcome_${currentUser.username}`, 'true');
            showStatus(chatStatus, 'Check out the features: Games, Voice Messages, and more!', 'info');
          }
          
          // Set up real-time friend request listener
          db.ref(`users/${currentUser.username}/friendRequests`).on('value', (snapshot) => {
            const requests = snapshot.val() || [];
            const previousCount = pendingRequests.length;
            pendingRequests = requests;
            updateRequestBadge();
            
            // Show notification for new friend requests
            if (requests.length > previousCount) {
              const newRequests = requests.slice(previousCount);
              newRequests.forEach(request => {
                if (request.from && request.from !== currentUser.username) {
                  notificationManager.showFriendRequestNotification(request.from);
                }
              });
            }
          });

          // Set up real-time friends list listener
          db.ref(`users/${currentUser.username}/friends`).on('value', (snapshot) => {
            const friends = snapshot.val() || [];
            currentUser.friends = friends;
            loadFriends();
          });

          // Set up real-time groups list listener
          db.ref(`users/${currentUser.username}/groups`).on('value', (snapshot) => {
            const groups = snapshot.val() ? Object.keys(snapshot.val()) : [];
            currentUser.groups = groups;
            loadGroups();
          });
        }, 1000);
      } catch (error) {
        console.error('Login error:', error);
        showStatus(loginStatus, `Error: ${error.message}`, 'error');
      } finally {
        loginBtn.disabled = false;
      }
    }

    // Logout user
    function logoutUser() {
      // Save current draft if any
      if (currentChat && messageInput.value.trim()) {
        messageDrafts[currentChat.id] = messageInput.value;
      }
      
      currentUser = null;
      localStorage.removeItem('currentUser');
      authContainer.style.display = 'flex';
      appContainer.style.display = 'none';
      document.getElementById('login-username').value = '';
      document.getElementById('login-password').value = '';
      messagesContainer.innerHTML = '';
      friendsList.innerHTML = `
        <div class="friend-item" id="add-friend-btn">
          <div class="friend-avatar"><i class="fas fa-user-plus"></i></div>
          <div class="friend-name">Add Friend</div>
        </div>
        <div class="friend-item" id="friend-requests-btn">
          <div class="friend-avatar"><i class="fas fa-user-clock"></i></div>
          <div class="friend-name">Friend Requests</div>
          <div id="request-badge" class="request-badge" style="display: none;"></div>
        </div>
        <div class="friend-item" id="create-group-btn">
          <div class="friend-avatar"><i class="fas fa-users"></i></div>
          <div class="friend-name">Create Group</div>
        </div>
      `;
      // Re-add event listeners
      document.getElementById('add-friend-btn').addEventListener('click', () => {
        addFriendModal.classList.add('active');
      });
      document.getElementById('friend-requests-btn').addEventListener('click', () => {
        requestsModal.classList.add('active');
      });
      document.getElementById('create-group-btn').addEventListener('click', () => {
        createGroupModal.classList.add('active');
      });
    }

    // Check if user is already logged in
    function checkAuth() {
      const savedUser = localStorage.getItem('currentUser');
      if (savedUser) {
        const { username, password } = JSON.parse(savedUser);
        document.getElementById('login-username').value = username;
        document.getElementById('login-password').value = password;
        // Attempt silent login from local DB snapshot without clicking UI
        db.ref(`users/${username}`).once('value').then(snap => {
          const user = snap.val();
          if (user && user.password === password) {
            currentUser = {
              uid: user.username,
              username: user.username,
              friends: user.friends || [],
              friendRequests: user.friendRequests || [],
              groups: user.groups ? Object.keys(user.groups) : [],
              blockedUsers: user.blockedUsers || [],
              profile: user.profile || { description: '', avatarUrl: '' }
            };
            authContainer.style.display = 'none';
            appContainer.style.display = 'flex';
            profileName.textContent = currentUser.username;
            profileAvatarText.textContent = currentUser.username.charAt(0).toUpperCase();
            loadFriends(); loadFriendRequests(); loadGroups();
          } else {
            authContainer.style.display = 'flex';
            appContainer.style.display = 'none';
          }
        }).catch(() => {
          authContainer.style.display = 'flex';
          appContainer.style.display = 'none';
        });
      } else {
        authContainer.style.display = 'flex';
        appContainer.style.display = 'none';
      }
    }

    // Load friends for the current user
    async function loadFriends() {
      try {
        // Clear existing friends
        friends = [];
        const friendsListItems = document.querySelectorAll('.friend-item:not(#add-friend-btn):not(#friend-requests-btn):not(#create-group-btn):not(#status-updates-btn)');
        friendsListItems.forEach(item => item.remove());
        
        // Add each friend to the list
        for (const friendUsername of currentUser.friends) {
          // Skip if friend is blocked
          if (currentUser.blockedUsers.includes(friendUsername)) continue;
          
          const snapshot = await db.ref(`users/${friendUsername}`).once('value');
          const friend = snapshot.val();
          
          if (friend) {
            friends.push({
              username: friend.username,
              status: 'online', // Simplified - in a real app you'd track this properly
              lastActivity: chatActivity[friend.username] || 0
            });
            
            const friendItem = document.createElement('div');
            friendItem.className = `friend-item ${hiddenChats[friend.username] ? 'hidden-chat' : ''}`;
            friendItem.dataset.username = friend.username;
            friendItem.innerHTML = `
              <div class="friend-avatar">${friend.username.charAt(0).toUpperCase()}</div>
              <div class="friend-name">${friend.username}</div>
              <div class="friend-status status-online"></div>
            `;
            
            friendItem.addEventListener('click', () => {
              openChat(friend.username, 'friend');
            });
            
            friendsList.appendChild(friendItem);
          }
        }
        
        // Sort friends by last activity (most recent first)
        sortFriendsList();
        
        console.log('Friends loaded:', friends.length);
      } catch (error) {
        console.error('Error loading friends:', error);
      }
    }

    // Sort friends list by most recent activity
    function sortFriendsList() {
      const container = document.getElementById('friends-list');
      const items = Array.from(document.querySelectorAll('.friend-item[data-username], .friend-item[data-group]'));
      
      // Sort items by last activity
      items.sort((a, b) => {
        const aActivity = chatActivity[a.dataset.username || a.dataset.group] || 0;
        const bActivity = chatActivity[b.dataset.username || b.dataset.group] || 0;
        return bActivity - aActivity;
      });
      
      // Re-add items in sorted order (after the first 4 fixed items)
      const fixedItems = Array.from(container.children).slice(0, 4);
      items.forEach(item => container.appendChild(item));
    }

    // Search chats
    function searchChats() {
      const searchTerm = chatSearchInput.value.toLowerCase();
      const allItems = document.querySelectorAll('.friend-item');
      
      allItems.forEach(item => {
        const name = item.querySelector('.friend-name')?.textContent.toLowerCase() || '';
        if (name.includes(searchTerm)) {
          item.style.display = 'flex';
        } else {
          item.style.display = 'none';
        }
      });
    }

    // Load friends for group creation
    async function loadFriendsForGroup() {
      try {
        friendsToAdd.innerHTML = '';
        
        for (const friendUsername of currentUser.friends) {
          // Skip if friend is blocked
          if (currentUser.blockedUsers.includes(friendUsername)) continue;
          
          const friendCheckbox = document.createElement('div');
          friendCheckbox.className = 'friend-checkbox';
          friendCheckbox.innerHTML = `
            <input type="checkbox" id="friend-${friendUsername}" value="${friendUsername}">
            <label for="friend-${friendUsername}">${friendUsername}</label>
          `;
          friendsToAdd.appendChild(friendCheckbox);
        }
      } catch (error) {
        console.error('Error loading friends for group:', error);
      }
    }

    // Load friends to add to existing group
    async function loadFriendsToAddToGroup() {
      try {
        friendsToAddToGroup.innerHTML = '';
        
        if (!currentChat || currentChat.type !== 'group') return;
        
        // Get current group members
        const groupSnapshot = await db.ref(`groups/${currentChat.id}`).once('value');
        const group = groupSnapshot.val();
        if (!group) return;
        
        const currentMembers = group.members.map(m => m.username);
        
        // Add friends not already in group
        for (const friendUsername of currentUser.friends) {
          if (!currentMembers.includes(friendUsername) && !currentUser.blockedUsers.includes(friendUsername)) {
            const friendCheckbox = document.createElement('div');
            friendCheckbox.className = 'friend-checkbox';
            friendCheckbox.innerHTML = `
              <input type="checkbox" id="add-to-group-${friendUsername}" value="${friendUsername}">
              <label for="add-to-group-${friendUsername}">${friendUsername}</label>
            `;
            friendsToAddToGroup.appendChild(friendCheckbox);
          }
        }
      } catch (error) {
        console.error('Error loading friends to add to group:', error);
      }
    }

    // Load friend requests
    async function loadFriendRequests() {
      try {
        requestsList.innerHTML = '';
        
        for (const requester of pendingRequests) {
          // Skip if requester is blocked
          if (currentUser.blockedUsers.includes(requester)) continue;
          
          const requestItem = document.createElement('div');
          requestItem.className = 'request-item';
          requestItem.innerHTML = `
            <div class="friend-info">
              <div class="friend-avatar">${requester.charAt(0).toUpperCase()}</div>
              <div class="friend-name">${requester}</div>
            </div>
            <div class="request-actions">
              <button class="accept-request" data-username="${requester}">
                <i class="fas fa-check"></i> Accept
              </button>
              <button class="reject-request" data-username="${requester}">
                <i class="fas fa-times"></i> Reject
              </button>
              <button class="block-request" data-username="${requester}" style="background: var(--error);">
                <i class="fas fa-ban"></i> Block
              </button>
            </div>
          `;
          
          requestsList.appendChild(requestItem);
        }
        
        // Add event listeners to accept/reject buttons
        document.querySelectorAll('.accept-request').forEach(btn => {
          btn.addEventListener('click', () => handleFriendRequest(btn.dataset.username, true));
        });
        
        document.querySelectorAll('.reject-request').forEach(btn => {
          btn.addEventListener('click', () => handleFriendRequest(btn.dataset.username, false));
        });
        
        document.querySelectorAll('.block-request').forEach(btn => {
          btn.addEventListener('click', () => blockUser(btn.dataset.username));
        });
      } catch (error) {
        console.error('Error loading friend requests:', error);
      }
    }

    // Update request badge
    function updateRequestBadge() {
      if (pendingRequests.length > 0) {
        requestBadge.style.display = 'flex';
        requestBadge.textContent = pendingRequests.length;
      } else {
        requestBadge.style.display = 'none';
      }
    }

    // Load groups for the current user
    async function loadGroups() {
      try {
        // Clear existing groups
        groups = [];
        const groupItems = document.querySelectorAll('.friend-item[data-group]');
        groupItems.forEach(item => item.remove());
        
        // Add each group to the list
        for (const groupId of currentUser.groups) {
          const snapshot = await db.ref(`groups/${groupId}`).once('value');
          const group = snapshot.val();
          
          if (group) {
            groups.push({
              id: groupId,
              name: group.name,
              creator: group.creator,
              members: group.members
            });
            
            const groupItem = document.createElement('div');
            groupItem.className = `friend-item ${hiddenChats[groupId] ? 'hidden-chat' : ''}`;
            groupItem.dataset.group = groupId;
            groupItem.innerHTML = `
              <div class="friend-avatar"><i class="fas fa-users"></i></div>
              <div class="friend-name">${group.name}</div>
              <div class="friend-status status-online"></div>
            `;
            
            groupItem.addEventListener('click', () => {
              openChat(groupId, 'group');
            });
            
            friendsList.appendChild(groupItem);
          }
        }
        
        // Sort groups by last activity
        sortFriendsList();
      } catch (error) {
        console.error('Error loading groups:', error);
      }
    }

    // Open a chat (friend or group)
    function openChat(id, type) {
      console.log('Opening chat:', id, type);
      currentChat = { id, type };
      messagesContainer.innerHTML = '';
      
      // Load any saved draft
      if (messageDrafts[id]) {
        messageInput.value = messageDrafts[id];
        messageInput.style.height = 'auto';
        messageInput.style.height = (messageInput.scrollHeight) + 'px';
      } else {
        messageInput.value = '';
        messageInput.style.height = 'auto';
      }
      
      const chatId = getChatId(id, type);
      
      if (type === 'friend') {
        chatTitle.textContent = id;
        chatActions.style.display = 'none';
        
        // Set up typing indicator listener
        db.ref(`typing/${chatId}`).on('value', (snapshot) => {
          const typingData = snapshot.val();
          if (typingData) {
            const typingUsers = Object.keys(typingData).filter(u => u !== currentUser.username);
            if (typingUsers.length > 0) {
              typingText.textContent = `${typingUsers[0]} is typing...`;
              typingIndicator.style.display = 'flex';
            } else {
              typingIndicator.style.display = 'none';
            }
          } else {
            typingIndicator.style.display = 'none';
          }
        });
      } else if (type === 'group') {
        const group = groups.find(g => g.id === id);
        if (group) {
          chatTitle.textContent = group.name;
          currentGroupMembers = group.members;
          
          // Only show actions if user is group creator
          if (group.creator === currentUser.username) {
            chatActions.style.display = 'flex';
          } else {
            chatActions.style.display = 'none';
          }
          
          // Set up typing indicator listener for group
          db.ref(`typing/${chatId}`).on('value', (snapshot) => {
            const typingData = snapshot.val();
            if (typingData) {
              const typingUsers = Object.keys(typingData).filter(u => u !== currentUser.username);
              if (typingUsers.length > 0) {
                if (typingUsers.length === 1) {
                  typingText.textContent = `${typingUsers[0]} is typing...`;
                } else if (typingUsers.length > 1) {
                  typingText.textContent = `${typingUsers.length} people are typing...`;
                }
                typingIndicator.style.display = 'flex';
              } else {
                typingIndicator.style.display = 'none';
              }
            } else {
              typingIndicator.style.display = 'none';
            }
          });
        }
      }
      
      // Load messages
      loadMessages(chatId, type);
      
      // Load pinned messages
      loadPinnedMessages(chatId, type);
      
      // Update chat activity
      chatActivity[id] = Date.now();
      sortFriendsList();
    }

    // Load messages for a chat
    function loadMessages(id, type) {
      // Clear existing messages
      messagesContainer.innerHTML = '';
      
      // Remove any existing listeners
      db.ref(`messages/${type}/${id}`).off('child_added');
      
      // Listen for new messages
      db.ref(`messages/${type}/${id}`).orderByChild('time').on('child_added', (snapshot) => {
        const msg = snapshot.val();
        console.log('New message received:', msg);
        const isCurrentUser = msg.userId === currentUser?.username;
        
        // Skip if message is from blocked user
        if (currentUser.blockedUsers.includes(msg.userId)) return;
        
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${isCurrentUser ? 'sent' : 'received'}`;
        msgDiv.dataset.messageId = snapshot.key;
        
        if (msg.type === "text" || msg.type === "deleted") {
          const isDeleted = msg.type === "deleted";
          const messageText = isDeleted ? `<div class="text" style="opacity: 0.6; font-style: italic;">ðŸ—‘ï¸ ${msg.text}</div>` : `<div class="text">${maybeDecrypt(msg.text || '')}</div>`;
          
          msgDiv.innerHTML = `
            <div class="message-actions">
              <div class="message-action" data-action="react"><i class="far fa-smile"></i></div>
              ${isCurrentUser && !isDeleted ? `
                <div class="message-action" data-action="edit"><i class="far fa-edit"></i></div>
                <div class="message-action" data-action="delete"><i class="far fa-trash-alt"></i></div>
                <div class="message-action" data-action="pin"><i class="fas fa-thumbtack"></i></div>
              ` : ''}
            </div>
            <div class="message-user-profile">
              <div class="message-user-avatar" data-username="${msg.username}">${msg.username.charAt(0).toUpperCase()}</div>
              <div class="message-username" data-username="${msg.username}">${msg.username} ${msg.username === 'Yug' ? '<span class="owner-badge">OWNER</span>' : ''}</div>
            </div>
            ${messageText}
            ${msg.music && !isDeleted ? `<div style=\"margin-top:6px;\"><audio controls src=\"${msg.music.url}\" style=\"width:260px;\"></audio></div>` : ''}
            ${msg.threadParent && !isDeleted ? `<div style="font-size:12px; opacity:0.8;">Replying to: ${msg.threadParentPreview || ''}</div>` : ''}
            ${msg.readBy && !isDeleted ? `<div style=\"font-size:10px; opacity:0.7;\">Seen by ${Object.keys(msg.readBy).length}</div>` : ''}
            ${msg.reactions && !isDeleted ? `
              <div class="reactions">
                ${Object.entries(msg.reactions).map(([reaction, users]) => `
                  <div class="reaction" data-reaction="${reaction}">
                    ${reaction} ${users.length}
                  </div>
                `).join('')}
              </div>
            ` : ''}
            <div class="timestamp">${formatTime(msg.time)} ${msg.edited ? '(edited)' : ''}</div>
            ${!isDeleted ? `<div style="display:flex; gap:6px; margin-top:6px;">
              <button class="reply-btn" data-id="${snapshot.key}" style="padding:4px 8px; font-size:12px;">Reply</button>
              ${!isCurrentUser ? `<button class=\"mark-read-btn\" data-id=\"${snapshot.key}\" style=\"padding:4px 8px; font-size:12px;\">Mark Read</button>` : ''}
              ${isCurrentUser ? `<button class=\"delete-me-btn\" data-id=\"${snapshot.key}\" style=\"padding:4px 8px; font-size:12px;\">Delete for me</button>` : ''}
            </div>` : ''}
          `;
        } else if (msg.type === "game") {
          msgDiv.innerHTML = `
            <div class="message-actions">
              <div class="message-action" data-action="react"><i class="far fa-smile"></i></div>
              ${isCurrentUser ? `
                <div class="message-action" data-action="delete"><i class="far fa-trash-alt"></i></div>
                <div class="message-action" data-action="pin"><i class="fas fa-thumbtack"></i></div>
              ` : ''}
            </div>
            <div class="message-user-profile">
              <div class="message-user-avatar" data-username="${msg.username}">${msg.username.charAt(0).toUpperCase()}</div>
              <div class="message-username" data-username="${msg.username}">${msg.username} ${msg.username === 'Yug' ? '<span class="owner-badge">OWNER</span>' : ''}</div>
            </div>
            <div class="game-container">
              <div style="padding:8px; background: rgba(255,255,255,0.05); border-radius:8px;">
                <b>ðŸŽ® Game: ${msg.game.toUpperCase()}</b>
                <div style="font-size:12px; opacity:0.8; margin:4px 0;">
                  ${msg.status === 'waiting' ? `Waiting for players (${msg.players?.length || 1}/2)` : 
                    msg.status === 'playing' ? `In progress - ${msg.state?.currentPlayer}'s turn` : 
                    msg.status === 'finished' ? `Game finished` : 'Game created'}
                </div>
                <div style="margin-top:8px;">
                  <button onclick="playGame('${msg.game}', '${msg.gameId || ''}')" style="padding:4px 8px; background: var(--accent); border:none; border-radius:4px; color:white; cursor:pointer;">
                    ${msg.status === 'waiting' ? 'Join Game' : 'View Game'}
                  </button>
                </div>
              </div>
            </div>
            ${msg.reactions ? `
              <div class="reactions">
                ${Object.entries(msg.reactions).map(([reaction, users]) => `
                  <div class="reaction" data-reaction="${reaction}">
                    ${reaction} ${users.length}
                  </div>
                `).join('')}
              </div>
            ` : ''}
            <div class="timestamp">${formatTime(msg.time)}</div>
          `;
        } else if (msg.type === "voice") {
          msgDiv.innerHTML = `
            <div class="message-actions">
              <div class="message-action" data-action="react"><i class="far fa-smile"></i></div>
              ${isCurrentUser ? `
                <div class="message-action" data-action="delete"><i class="far fa-trash-alt"></i></div>
                <div class="message-action" data-action="pin"><i class="fas fa-thumbtack"></i></div>
              ` : ''}
            </div>
            <div class="message-user-profile">
              <div class="message-user-avatar" data-username="${msg.username}">${msg.username.charAt(0).toUpperCase()}</div>
              <div class="message-username" data-username="${msg.username}">${msg.username} ${msg.username === 'Yug' ? '<span class="owner-badge">OWNER</span>' : ''}</div>
            </div>
            <div class="voice-message">
              <audio controls style="width: 260px; height: 40px;">
                <source src="${msg.url}" type="audio/webm">
                Your browser does not support the audio element.
              </audio>
              <div style="font-size: 12px; opacity: 0.7; margin-top: 4px;">
                ðŸŽ¤ Voice message ${msg.duration ? `(${msg.duration}s)` : ''}
              </div>
            </div>
            ${msg.reactions ? `
              <div class="reactions">
                ${Object.entries(msg.reactions).map(([reaction, users]) => `
                  <div class="reaction" data-reaction="${reaction}">
                    ${reaction} ${users.length}
                  </div>
                `).join('')}
              </div>
            ` : ''}
            <div class="timestamp">${formatTime(msg.time)}</div>
          `;
        } else if (msg.type === "image") {
          msgDiv.innerHTML = `
            <div class="message-actions">
              <div class="message-action" data-action="react"><i class="far fa-smile"></i></div>
              ${isCurrentUser ? `
                <div class="message-action" data-action="delete"><i class="far fa-trash-alt"></i></div>
                <div class="message-action" data-action="pin"><i class="fas fa-thumbtack"></i></div>
              ` : ''}
            </div>
            <div class="message-user-profile">
              <div class="message-user-avatar" data-username="${msg.username}">${msg.username.charAt(0).toUpperCase()}</div>
              <div class="message-username" data-username="${msg.username}">${msg.username} ${msg.username === 'Yug' ? '<span class="owner-badge">OWNER</span>' : ''}</div>
            </div>
            <div class="image-container">
              <img src="${msg.url}" alt="Sent image">
              ${msg.linkMeta ? `<div class="link-card"><div>${msg.linkMeta.title || ''}</div><div style="font-size:12px;opacity:0.8;">${msg.linkMeta.url || ''}</div></div>` : ''}
            </div>
            ${msg.reactions ? `
              <div class="reactions">
                ${Object.entries(msg.reactions).map(([reaction, users]) => `
                  <div class="reaction" data-reaction="${reaction}">
                    ${reaction} ${users.length}
                  </div>
                `).join('')}
              </div>
            ` : ''}
            <div class="timestamp">${formatTime(msg.time)}</div>
          `;
        }
        
        messagesContainer.appendChild(msgDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // Show notification for new messages (not from current user and not in current chat)
        if (!isCurrentUser && (!currentChat || getChatId(currentChat.id, currentChat.type) !== id)) {
          const messageText = msg.type === 'text' ? maybeDecrypt(msg.text || '') : 
                            msg.type === 'image' ? 'ðŸ“· Image' :
                            msg.type === 'voice' ? 'ðŸŽ¤ Voice message' :
                            msg.type === 'game' ? `ðŸŽ® ${msg.game} game` :
                            'New message';
          
          // Check if user is mentioned in the message
          const isMentioned = msg.type === 'text' && messageText.toLowerCase().includes(`@${currentUser.username.toLowerCase()}`);
          
          if (isMentioned) {
            notificationManager.showInAppNotification(
              `@${currentUser.username} mentioned you!`, 
              `${msg.username}: ${messageText}`, 
              'message', 
              8000
            );
          } else {
            notificationManager.showMessageNotification(msg.username, messageText, type, id);
          }
        }
        
        // Add click event to profile elements
        document.querySelectorAll(`[data-username="${msg.username}"]`).forEach(el => {
          el.addEventListener('click', () => viewUserProfile(msg.username));
        });
        
        // Add click events to message actions
        msgDiv.querySelectorAll('.message-action').forEach(action => {
          action.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Message action clicked:', action.dataset.action);
            handleMessageAction(action.dataset.action, snapshot.key, msg);
          });
        });
        
        // Add click events to reply, mark read, and delete buttons
        msgDiv.querySelectorAll('.reply-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            promptThreadReply(snapshot.key, msg);
          });
        });
        
        msgDiv.querySelectorAll('.mark-read-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            markMessageRead(id, btn.dataset.id, true);
          });
        });
        
        msgDiv.querySelectorAll('.delete-me-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            deleteForMe(id, btn.dataset.id);
          });
        });
        
        // Add click events to reactions
        if (msgDiv.querySelector('.reactions')) {
          msgDiv.querySelectorAll('.reaction').forEach(reaction => {
            reaction.addEventListener('click', (e) => {
              e.stopPropagation();
              toggleReaction(snapshot.key, reaction.dataset.reaction, msg);
            });
          });
        }
        // Read receipts
        if (!isCurrentUser) markMessageRead(id, snapshot.key);
        // Reply/read/delete-me shortcuts
        msgDiv.querySelectorAll('.reply-btn')?.forEach(btn => btn.addEventListener('click', () => promptThreadReply(snapshot.key, msg)));
        msgDiv.querySelectorAll('.mark-read-btn')?.forEach(btn => btn.addEventListener('click', () => markMessageRead(id, btn.dataset.id, true)));
        msgDiv.querySelectorAll('.delete-me-btn')?.forEach(btn => btn.addEventListener('click', () => deleteForMe(id, btn.dataset.id)));
      });
    }

    // Load pinned messages for a chat
    function loadPinnedMessages(id, type) {
      pinnedMessagesList.innerHTML = '';
      
      db.ref(`pinnedMessages/${type}/${id}`).orderByChild('time').once('value', (snapshot) => {
        const pinnedMessages = snapshot.val();
        if (pinnedMessages) {
          pinnedMessagesContainer.style.display = 'block';
          
          Object.entries(pinnedMessages).forEach(([key, msg]) => {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${msg.userId === currentUser?.username ? 'sent' : 'received'}`;
            msgDiv.style.marginBottom = '8px';
            
            if (msg.type === "text") {
              msgDiv.innerHTML = `
                <div class="message-user-profile">
                  <div class="message-user-avatar" data-username="${msg.username}">${msg.username.charAt(0).toUpperCase()}</div>
                  <div class="message-username" data-username="${msg.username}">${msg.username} ${msg.username === 'Yug' ? '<span class="owner-badge">OWNER</span>' : ''}</div>
                </div>
                <div class="text">${maybeDecrypt(msg.text)}</div>
                <div class="timestamp">${formatTime(msg.time)} ${msg.edited ? '(edited)' : ''}</div>
              `;
            } else if (msg.type === "image") {
              msgDiv.innerHTML = `
                <div class="message-user-profile">
                  <div class="message-user-avatar" data-username="${msg.username}">${msg.username.charAt(0).toUpperCase()}</div>
                  <div class="message-username" data-username="${msg.username}">${msg.username} ${msg.username === 'Yug' ? '<span class="owner-badge">OWNER</span>' : ''}</div>
                </div>
                <div class="image-container">
                  <img src="${msg.url}" alt="Sent image" style="max-height: 100px;">
                </div>
                <div class="timestamp">${formatTime(msg.time)}</div>
              `;
            }
            
            pinnedMessagesList.appendChild(msgDiv);
            
            // Add click event to profile elements
            document.querySelectorAll(`[data-username="${msg.username}"]`).forEach(el => {
              el.addEventListener('click', () => viewUserProfile(msg.username));
            });
          });
        } else {
          pinnedMessagesContainer.style.display = 'none';
        }
      });
    }

    // Handle message actions (edit, delete, react, pin)
    function handleMessageAction(action, messageId, message) {
      if (!currentChat) return;
      
      console.log('Handling message action:', action, 'for message:', messageId);
      
      switch (action) {
        case 'edit':
          editMessage(messageId, message);
          break;
        case 'delete':
          deleteMessage(messageId);
          break;
        case 'react':
          selectedMessageForReaction = messageId;
          reactionPickerModal.classList.add('active');
          break;
        case 'pin':
          pinMessage(messageId, message);
          break;
        default:
          console.log('Unknown action:', action);
      }
    }

    // Edit a message
    function editMessage(messageId, message) {
      if (message.type !== 'text') return;
      // Allow edit only within 15 minutes
      if (Date.now() - (message.time || 0) > 15 * 60 * 1000) {
        alert('You can only edit messages within 15 minutes');
        return;
      }
      const newText = prompt('Edit your message:', message.text);
      if (newText && newText !== message.text) {
        const chatId = getChatId(currentChat.id, currentChat.type);
        db.ref(`messages/${currentChat.type}/${chatId}/${messageId}`).update({
          text: newText,
          edited: true
        });
      }
    }

    // Delete a message
    function deleteMessage(messageId) {
      if (!currentChat) return;
      
      if (confirm('Are you sure you want to delete this message?')) {
        const chatId = getChatId(currentChat.id, currentChat.type);
        console.log('Deleting message:', messageId, 'from chat:', chatId);
        
        // First get the message to show who deleted it
        db.ref(`messages/${currentChat.type}/${chatId}/${messageId}`).once('value')
          .then((snapshot) => {
            const message = snapshot.val();
            if (message) {
              // Replace message with deletion notice
              db.ref(`messages/${currentChat.type}/${chatId}/${messageId}`).update({
                type: 'deleted',
                text: `${currentUser.username} deleted this message`,
                time: Date.now(),
                username: currentUser.username,
                userId: currentUser.username,
                originalMessage: message
              });
              showStatus(chatStatus, 'Message deleted successfully', 'success');
            }
          })
          .catch((error) => {
            console.error('Error deleting message:', error);
            showStatus(chatStatus, 'Error deleting message', 'error');
          });
        
        // Also remove from pinned messages if it was pinned
        db.ref(`pinnedMessages/${currentChat.type}/${chatId}/${messageId}`).remove();
      }
    }

    function deleteForMe(chatIdRaw, messageId) {
      // Client-side hide only using localStorage key
      const hideKey = `hide_${currentUser.username}_${currentChat.type}_${chatIdRaw}`;
      const hidden = JSON.parse(localStorage.getItem(hideKey) || '[]');
      if (!hidden.includes(messageId)) hidden.push(messageId);
      localStorage.setItem(hideKey, JSON.stringify(hidden));
      loadMessages(getChatId(currentChat.id, currentChat.type), currentChat.type);
    }

    // Pin a message
    function pinMessage(messageId, message) {
      const chatId = getChatId(currentChat.id, currentChat.type);
      db.ref(`pinnedMessages/${currentChat.type}/${chatId}/${messageId}`).set(message);
      showStatus(chatStatus, 'Message pinned', 'success');
    }

    // Add or toggle reaction
    function toggleReaction(messageId, reaction, message) {
      if (!currentChat) return;
      
      const chatId = getChatId(currentChat.id, currentChat.type);
      const reactionRef = db.ref(`messages/${currentChat.type}/${chatId}/${messageId}/reactions/${reaction}`);
      
      reactionRef.transaction((currentUsers) => {
        currentUsers = currentUsers || [];
        
        // If user already reacted with this emoji, remove their reaction
        const userIndex = currentUsers.indexOf(currentUser.username);
        if (userIndex !== -1) {
          currentUsers.splice(userIndex, 1);
          // If no more reactions of this type, remove the reaction entirely
          if (currentUsers.length === 0) {
            return null;
          }
        } else {
          // Add user's reaction
          currentUsers.push(currentUser.username);
        }
        
        return currentUsers;
      });
    }

    // Send text message
    function sendText() {
      if (messageSendLock) return;
      
      const text = messageInput.value.trim();
      if (!text && !selectedImage) {
        showStatus(chatStatus, 'Message cannot be empty', 'error');
        return;
      }

      if (!currentUser || !currentChat) {
        showStatus(chatStatus, 'You need to open a chat first', 'error');
        return;
      }

      if (selectedImage) {
        uploadImage();
        return;
      }

      messageSendLock = true;
      
      const chatId = getChatId(currentChat.id, currentChat.type);
      console.log('Sending message to chat:', chatId);
      
      const ttlMs = window.nextMessageTTL || 0;
      window.nextMessageTTL = null; // Reset after use
      db.ref(`messages/${currentChat.type}/${chatId}`).push({
        type: "text",
        text: maybeEncrypt(text),
        time: Date.now(),
        username: currentUser.username,
        userId: currentUser.username,
        edited: false,
        ttl: ttlMs > 0 ? ttlMs : null
      })
      .then(() => {
        // Update chat activity
        chatActivity[currentChat.id] = Date.now();
        sortFriendsList();
        
        // Clear draft
        delete messageDrafts[currentChat.id];
        messageInput.value = '';
        messageInput.style.height = 'auto';
        messageInput.focus();
        
        // Clear typing indicator
        if (currentChat.type === 'friend') {
          db.ref(`typing/${chatId}/${currentUser.username}`).remove();
        }
        
        showStatus(chatStatus, 'Message sent!', 'success');
      })
      .catch(error => {
        console.error('Error sending message:', error);
        showStatus(chatStatus, `Error: ${error.message}`, 'error');
      })
      .finally(() => {
        messageSendLock = false;
      });
    }

    // Handle image upload selection
    function handleImageUpload() {
      const file = uploadInput.files[0];
      if (!file) return;

      // Validate file type
      if (!file.type.match('image.*')) {
        showStatus(chatStatus, 'Only images are allowed', 'error');
        uploadInput.value = '';
        return;
      }

      // Validate file size (max 5MB)
      if (file.size > 5 * 1024 * 1024) {
        showStatus(chatStatus, 'Image must be smaller than 5MB', 'error');
        uploadInput.value = '';
        return;
      }

      selectedImage = file;
      
      // Show preview
      const reader = new FileReader();
      reader.onload = function(e) {
        const filter = document.getElementById('photo-filter-select')?.value || 'none';
        imagePreview.style.filter = filter;
        imagePreview.src = e.target.result;
        imagePreview.classList.add('visible');
        removeImageBtn.style.display = 'block';
        sendImageBtn.disabled = false;
      };
      reader.readAsDataURL(file);
    }

    // Remove selected image
    function removeImage() {
      selectedImage = null;
      imagePreview.src = '';
      imagePreview.classList.remove('visible');
      removeImageBtn.style.display = 'none';
      uploadInput.value = '';
      sendImageBtn.disabled = true;
    }

    // Upload and send image
    async function uploadImage() {
      if (!selectedImage) {
        showStatus(chatStatus, 'Please select an image first', 'error');
        return;
      }

      if (!currentUser || !currentChat) {
        showStatus(chatStatus, 'You need to open a chat first', 'error');
        return;
      }

      if (messageSendLock) return;
      messageSendLock = true;
      
      sendImageBtn.disabled = true;
      showStatus(chatStatus, 'Uploading image...', 'loading');

      try {
        // Optional: basic photo filters (CSS-based export)
        const filter = document.getElementById('photo-filter-select')?.value || 'none';
        const formData = new FormData();
        formData.append("key", "6d207e02198a847aa98d0a2a901485a5");
        formData.append("action", "upload");
        formData.append("source", selectedImage);
        formData.append("format", "json");
        
        console.log('Uploading image to FreeImage.host...', selectedImage.name);
        const res = await fetch("https://freeimage.host/api/1/upload", {
          method: "POST",
          body: formData
        });
        
        console.log('Upload response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`Upload failed with status: ${res.status}`);
        }
        
        const data = await res.json();
        console.log('Upload response data:', data);
        
        if (!data.success) {
          throw new Error(data.error?.message || 'Image upload failed');
        }
        
        let imageUrl = data.image.url;
        console.log('Image uploaded successfully:', imageUrl);
        
        if (!imageUrl) {
          throw new Error('No image URL received from upload service');
        }
        
        const chatId = getChatId(currentChat.id, currentChat.type);
        
        await db.ref(`messages/${currentChat.type}/${chatId}`).push({
          type: "image",
          url: imageUrl,
          time: Date.now(),
          username: currentUser.username,
          userId: currentUser.username,
          ttl: parseInt(ttlSelect?.value || '0', 10) || null
        });
        
        // Update chat activity
        chatActivity[currentChat.id] = Date.now();
        sortFriendsList();
        
        showStatus(chatStatus, 'Image sent successfully', 'success');
        removeImage();
      } catch (error) {
        console.error('Upload error:', error);
        
        // Try fallback upload method
        try {
          showStatus(chatStatus, 'Trying fallback upload...', 'loading');
          
          // Convert image to base64 as fallback
          const reader = new FileReader();
          reader.onload = async function(e) {
            const base64Data = e.target.result.split(',')[1];
            
            const fallbackFormData = new FormData();
            fallbackFormData.append("key", "6d207e02198a847aa98d0a2a901485a5");
            fallbackFormData.append("action", "upload");
            fallbackFormData.append("source", `data:image/jpeg;base64,${base64Data}`);
            fallbackFormData.append("format", "json");
            
            const fallbackRes = await fetch("https://freeimage.host/api/1/upload", {
              method: "POST",
              body: fallbackFormData
            });
            
            const fallbackData = await fallbackRes.json();
            
            if (fallbackData.success && fallbackData.image.url) {
              const chatId = getChatId(currentChat.id, currentChat.type);
              await db.ref(`messages/${currentChat.type}/${chatId}`).push({
                type: "image",
                url: fallbackData.image.url,
                time: Date.now(),
                username: currentUser.username,
                userId: currentUser.username,
                ttl: parseInt(ttlSelect?.value || '0', 10) || null
              });
              
              showStatus(chatStatus, 'Image sent successfully (fallback)', 'success');
              removeImage();
            } else {
              throw new Error('Fallback upload also failed');
            }
          };
          reader.readAsDataURL(selectedImage);
        } catch (fallbackError) {
          console.error('Fallback upload error:', fallbackError);
          showStatus(chatStatus, `Image upload failed: ${error.message}`, 'error');
        }
      } finally {
        sendImageBtn.disabled = false;
        messageSendLock = false;
      }
    }

    // Voice message recording
    async function handleVoiceRecord() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        recordVoiceBtn.innerHTML = '<i class="fas fa-microphone"></i>';
        recordVoiceBtn.title = 'Voice Message';
        return;
      }
      
      if (!currentChat) {
        showStatus(chatStatus, 'Open a chat first', 'error');
        return;
      }
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        
        mediaRecorder.ondataavailable = e => { 
          if (e.data.size > 0) recordedChunks.push(e.data); 
        };
        
        mediaRecorder.onstop = async () => {
          try {
            showStatus(chatStatus, 'Sending voice message...', 'loading');
            
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const fileName = `voice_${Date.now()}.webm`;
            const storageRef = storage.ref().child(`voice/${currentUser.username}/${fileName}`);
            await storageRef.put(blob);
            const url = await storageRef.getDownloadURL();
            
            const chatId = getChatId(currentChat.id, currentChat.type);
            await db.ref(`messages/${currentChat.type}/${chatId}`).push({
              type: 'voice', 
              url, 
              time: Date.now(), 
              username: currentUser.username, 
              userId: currentUser.username,
              duration: Math.round(recordedChunks.length * 0.1) // Approximate duration
            });
            
            showStatus(chatStatus, 'Voice message sent', 'success');
          } catch (error) {
            console.error('Error sending voice message:', error);
            showStatus(chatStatus, 'Error sending voice message', 'error');
          }
        };
        
        mediaRecorder.start();
        recordVoiceBtn.innerHTML = '<i class="fas fa-stop"></i>';
        recordVoiceBtn.title = 'Stop Recording';
        showStatus(chatStatus, 'Recording voice message...', 'info');
        
      } catch (e) {
        console.error('Microphone error:', e);
        showStatus(chatStatus, `Microphone access denied: ${e.message}`, 'error');
      }
    }

    // Generic file upload (PDFs, docs, zips)
    async function handleFileUpload() {
      const file = fileUpload.files[0];
      if (!file) return;
      if (!currentUser || !currentChat) {
        showStatus(chatStatus, 'Open a chat first', 'error');
        return;
      }
      showStatus(chatStatus, 'Uploading file...', 'loading');
      try {
        const storageRef = storage.ref().child(`uploads/${currentUser.username}/${Date.now()}_${file.name}`);
        await storageRef.put(file);
        const url = await storageRef.getDownloadURL();
        const chatId = getChatId(currentChat.id, currentChat.type);
        await db.ref(`messages/${currentChat.type}/${chatId}`).push({
          type: 'file',
          url,
          fileName: file.name,
          time: Date.now(),
          username: currentUser.username,
          userId: currentUser.username,
          ttl: parseInt(ttlSelect?.value || '0', 10) || null
        });
        showStatus(chatStatus, 'File sent', 'success');
        fileUpload.value = '';
      } catch (e) {
        console.error(e);
        showStatus(chatStatus, `Error: ${e.message}`, 'error');
      }
    }

    // Send friend request
    async function sendFriendRequest() {
      const username = friendUsernameInput.value.trim();

      if (!username) {
        showStatus(friendStatus, 'Username is required', 'error');
        return;
      }

      if (username === currentUser.username) {
        showStatus(friendStatus, 'You cannot add yourself', 'error');
        return;
      }

      showStatus(friendStatus, 'Sending request...', 'loading');
      sendRequestBtn.disabled = true;

      try {
        // Check if user exists
        const snapshot = await db.ref(`users/${username}`).once('value');
        const targetUser = snapshot.val();
        
        if (!targetUser) {
          throw new Error('User not found');
        }
        
        // Check if already friends
        if (currentUser.friends.includes(username)) {
          throw new Error('Already friends with this user');
        }
        
        // Check if request already sent
        if (targetUser.friendRequests && targetUser.friendRequests.includes(currentUser.username)) {
          throw new Error('Request already sent');
        }
        
        // Check if user is blocked
        if (targetUser.blockedUsers && targetUser.blockedUsers.includes(currentUser.username)) {
          throw new Error('You are blocked by this user');
        }
        
        // Check if you've blocked this user
        if (currentUser.blockedUsers.includes(username)) {
          throw new Error('You have blocked this user');
        }
        
        // Add request to target user's friendRequests array
        await db.ref(`users/${username}/friendRequests`).transaction((requests) => {
          requests = requests || [];
          if (!requests.includes(currentUser.username)) {
            requests.push(currentUser.username);
          }
          return requests;
        });

        showStatus(friendStatus, 'Friend request sent!', 'success');
        friendUsernameInput.value = '';
        
        // Close modal
        setTimeout(() => {
          addFriendModal.classList.remove('active');
        }, 1500);
      } catch (error) {
        console.error('Friend request error:', error);
        showStatus(friendStatus, `Error: ${error.message}`, 'error');
      } finally {
        sendRequestBtn.disabled = false;
      }
    }

    // Handle friend request (accept/reject)
    async function handleFriendRequest(requester, accept) {
      try {
        showStatus(requestsStatus, 'Processing request...', 'loading');
        
        // Remove request from current user's friendRequests
        await db.ref(`users/${currentUser.username}/friendRequests`).transaction((requests) => {
          requests = requests || [];
          return requests.filter(r => r !== requester);
        });
        
        if (accept) {
          // Add each other as friends
          await db.ref(`users/${currentUser.username}/friends`).transaction((friends) => {
            friends = friends || [];
            if (!friends.includes(requester)) {
              friends.push(requester);
            }
            return friends;
          });
          
          await db.ref(`users/${requester}/friends`).transaction((friends) => {
            friends = friends || [];
            if (!friends.includes(currentUser.username)) {
              friends.push(currentUser.username);
            }
            return friends;
          });
          
          // Update current user's friends list
          if (!currentUser.friends.includes(requester)) {
            currentUser.friends.push(requester);
          }
          
          showStatus(requestsStatus, 'Friend request accepted!', 'success');
          
          // Reload friends list and open chat with new friend
          await loadFriends();
          openChat(requester, 'friend');
        } else {
          showStatus(requestsStatus, 'Friend request rejected', 'success');
        }
        
        // Update pending requests
        pendingRequests = pendingRequests.filter(r => r !== requester);
        updateRequestBadge();
        
        // Reload requests list
        loadFriendRequests();
      } catch (error) {
        console.error('Error handling friend request:', error);
        showStatus(requestsStatus, `Error: ${error.message}`, 'error');
      }
    }

    // Create a new group chat
    async function createGroup() {
      const name = groupNameInput.value.trim();
      
      if (!name) {
        showStatus(groupStatus, 'Group name is required', 'error');
        return;
      }

      showStatus(groupStatus, 'Creating group...', 'loading');
      createGroupConfirmBtn.disabled = true;

      try {
        // Get selected members
        const selectedMembers = Array.from(document.querySelectorAll('#friends-to-add input:checked'))
          .map(input => input.value);
        
        // Create group object
        const groupId = 'group-' + Date.now();
        const newGroup = {
          id: groupId,
          name,
          creator: currentUser.username,
          members: [
            { username: currentUser.username, role: 'creator' },
            ...selectedMembers.map(username => ({ username, role: 'member' }))
          ],
          createdAt: Date.now()
        };
        
        // Add group to database
        await db.ref(`groups/${groupId}`).set(newGroup);
        
        // Add group to each member's groups array
        const updates = {};
        newGroup.members.forEach(member => {
          updates[`users/${member.username}/groups/${groupId}`] = true;
        });
        await db.ref().update(updates);

        // Update current user's groups
        if (!currentUser.groups.includes(groupId)) {
          currentUser.groups.push(groupId);
        }

        showStatus(groupStatus, 'Group created successfully!', 'success');
        
        // Clear form
        groupNameInput.value = '';
        document.querySelectorAll('#friends-to-add input').forEach(input => {
          input.checked = false;
        });
        
        // Close modal and reload groups
        setTimeout(() => {
          createGroupModal.classList.remove('active');
          loadGroups();
          openChat(groupId, 'group');
        }, 1500);
      } catch (error) {
        console.error('Group creation error:', error);
        showStatus(groupStatus, `Error: ${error.message}`, 'error');
      } finally {
        createGroupConfirmBtn.disabled = false;
      }
    }

    // Add friends to existing group
    async function addFriendsToGroup() {
      if (!currentChat || currentChat.type !== 'group') {
        showStatus(addFriendsStatus, 'Not in a group chat', 'error');
        return;
      }

      showStatus(addFriendsStatus, 'Adding friends...', 'loading');
      addFriendsToGroupConfirmBtn.disabled = true;

      try {
        // Get selected members
        const selectedMembers = Array.from(document.querySelectorAll('#friends-to-add-to-group input:checked'))
          .map(input => input.value);
        
        if (selectedMembers.length === 0) {
          throw new Error('No friends selected');
        }
        
        // Get current group
        const groupSnapshot = await db.ref(`groups/${currentChat.id}`).once('value');
        const group = groupSnapshot.val();
        
        if (!group) {
          throw new Error('Group not found');
        }
        
        // Add new members to group
        const updatedMembers = [...group.members];
        for (const username of selectedMembers) {
          if (!updatedMembers.some(m => m.username === username)) {
            updatedMembers.push({ username, role: 'member' });
          }
        }
        
        // Update group in database
        await db.ref(`groups/${currentChat.id}/members`).set(updatedMembers);
        
        // Add group to each new member's groups array
        const updates = {};
        selectedMembers.forEach(username => {
          updates[`users/${username}/groups/${currentChat.id}`] = true;
        });
        await db.ref().update(updates);

        showStatus(addFriendsStatus, 'Friends added to group!', 'success');
        
        // Clear selections
        document.querySelectorAll('#friends-to-add-to-group input').forEach(input => {
          input.checked = false;
        });
        
        // Close modal and reload group info
        setTimeout(() => {
          addFriendsToGroupModal.classList.remove('active');
          loadGroups();
          openChat(currentChat.id, 'group');
        }, 1500);
      } catch (error) {
        console.error('Error adding friends to group:', error);
        showStatus(addFriendsStatus, `Error: ${error.message}`, 'error');
      } finally {
        addFriendsToGroupConfirmBtn.disabled = false;
      }
    }

    // Leave a group
    async function leaveGroup() {
      if (!currentChat || currentChat.type !== 'group') {
        showStatus(chatStatus, 'Not in a group chat', 'error');
        return;
      }

      if (confirm('Are you sure you want to leave this group?')) {
        showStatus(chatStatus, 'Leaving group...', 'loading');
        
        try {
          // Get group info
          const groupSnapshot = await db.ref(`groups/${currentChat.id}`).once('value');
          const group = groupSnapshot.val();
          
          if (!group) {
            throw new Error('Group not found');
          }
          
          // Remove user from group members
          const updatedMembers = group.members.filter(m => m.username !== currentUser.username);
          
          // If no members left, delete the group
          if (updatedMembers.length === 0) {
            await db.ref(`groups/${currentChat.id}`).remove();
          } else {
            await db.ref(`groups/${currentChat.id}/members`).set(updatedMembers);
          }
          
          // Remove group from user's groups list
          await db.ref(`users/${currentUser.username}/groups/${currentChat.id}`).remove();

          // Update current user's groups
          currentUser.groups = currentUser.groups.filter(g => g !== currentChat.id);

          showStatus(chatStatus, 'You have left the group', 'success');
          
          // Close the chat
          currentChat = null;
          messagesContainer.innerHTML = '';
          chatTitle.textContent = 'Direct Messages';
          chatActions.style.display = 'none';
          
          // Reload groups
          loadGroups();
        } catch (error) {
          console.error('Leave group error:', error);
          showStatus(chatStatus, `Error: ${error.message}`, 'error');
        }
      }
    }

    // Kick a member from group
    async function kickMember() {
      if (!currentChat || currentChat.type !== 'group' || !currentGroupMembers) {
        showStatus(chatStatus, 'Not in a group chat', 'error');
        return;
      }

      // Show list of members to kick (excluding self)
      const membersToKick = currentGroupMembers
        .filter(m => m.username !== currentUser.username)
        .map(m => m.username);
      
      if (membersToKick.length === 0) {
        showStatus(chatStatus, 'No members to kick', 'error');
        return;
      }

      const memberToKick = prompt(`Enter username to kick:\n${membersToKick.join('\n')}`);
      if (!memberToKick || !membersToKick.includes(memberToKick)) {
        return;
      }

      if (confirm(`Are you sure you want to kick ${memberToKick} from the group?`)) {
        showStatus(chatStatus, 'Kicking member...', 'loading');
        
        try {
          // Get group info
          const groupSnapshot = await db.ref(`groups/${currentChat.id}`).once('value');
          const group = groupSnapshot.val();
          
          if (!group) {
            throw new Error('Group not found');
          }
          
          // Remove member from group
          const updatedMembers = group.members.filter(m => m.username !== memberToKick);
          await db.ref(`groups/${currentChat.id}/members`).set(updatedMembers);
          
          // Remove group from kicked user's groups list
          await db.ref(`users/${memberToKick}/groups/${currentChat.id}`).remove();

          showStatus(chatStatus, `${memberToKick} has been kicked from the group`, 'success');
          
          // Reload group info
          const updatedGroupSnapshot = await db.ref(`groups/${currentChat.id}`).once('value');
          const updatedGroup = updatedGroupSnapshot.val();
          if (updatedGroup) {
            currentGroupMembers = updatedGroup.members;
          }
        } catch (error) {
          console.error('Kick member error:', error);
          showStatus(chatStatus, `Error: ${error.message}`, 'error');
        }
      }
    }

    // Enhanced Settings System
    function saveSettings() {
      const selectedTheme = document.querySelector('.theme-option.active')?.dataset.theme || 'default';
      
      // Save theme and settings to localStorage
      const settings = {
        theme: selectedTheme,
        messageAnimations: document.getElementById('message-animations')?.checked ?? true,
        soundEffects: document.getElementById('sound-effects')?.checked ?? true,
        typingIndicator: document.getElementById('typing-indicator')?.checked ?? true,
        compactMode: document.getElementById('compact-mode')?.checked ?? false,
        showTimestamps: document.getElementById('show-timestamps')?.checked ?? true,
        autoScroll: document.getElementById('auto-scroll')?.checked ?? true
      };
      
      localStorage.setItem('appSettings', JSON.stringify(settings));
      localStorage.setItem('selectedTheme', selectedTheme);
      
      // Apply theme
      applyTheme(selectedTheme);
      
      // Apply other settings
      applySettings(settings);
      
      showStatus(settingsStatus, 'Settings saved permanently!', 'success');
      setTimeout(() => {
        settingsModal.classList.remove('active');
      }, 1500);
    }

    function applyTheme(theme) {
      // Remove existing theme classes
      document.body.className = document.body.className.replace(/theme-\w+/g, '');
      
      // Apply new theme
      document.body.classList.add(`theme-${theme}`);
      
      // Apply theme-specific styles
      const root = document.documentElement;
      
      switch(theme) {
        case 'ocean':
          root.style.setProperty('--bg-dark', '#0c4a6e');
          root.style.setProperty('--bg-card', '#0284c7');
          root.style.setProperty('--accent', '#0ea5e9');
          root.style.setProperty('--sent-bg', 'linear-gradient(135deg, #0284c7 0%, #0ea5e9 100%)');
          break;
        case 'sunset':
          root.style.setProperty('--bg-dark', '#dc2626');
          root.style.setProperty('--bg-card', '#ea580c');
          root.style.setProperty('--accent', '#f59e0b');
          root.style.setProperty('--sent-bg', 'linear-gradient(135deg, #ea580c 0%, #f59e0b 100%)');
          break;
        case 'forest':
          root.style.setProperty('--bg-dark', '#166534');
          root.style.setProperty('--bg-card', '#16a34a');
          root.style.setProperty('--accent', '#22c55e');
          root.style.setProperty('--sent-bg', 'linear-gradient(135deg, #16a34a 0%, #22c55e 100%)');
          break;
        case 'neon':
          root.style.setProperty('--bg-dark', '#7c3aed');
          root.style.setProperty('--bg-card', '#a855f7');
          root.style.setProperty('--accent', '#ec4899');
          root.style.setProperty('--sent-bg', 'linear-gradient(135deg, #a855f7 0%, #ec4899 100%)');
          break;
        case 'dark':
          root.style.setProperty('--bg-dark', '#000000');
          root.style.setProperty('--bg-card', '#1f2937');
          root.style.setProperty('--accent', '#6b7280');
          root.style.setProperty('--sent-bg', 'linear-gradient(135deg, #1f2937 0%, #374151 100%)');
          break;
        case 'light':
          root.style.setProperty('--bg-dark', '#f8fafc');
          root.style.setProperty('--bg-card', '#e2e8f0');
          root.style.setProperty('--accent', '#3b82f6');
          root.style.setProperty('--text-primary', '#1e293b');
          root.style.setProperty('--text-secondary', '#64748b');
          root.style.setProperty('--sent-bg', 'linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%)');
          break;
        case 'animated':
          root.style.setProperty('--bg-dark', '#ee7752');
          root.style.setProperty('--bg-card', '#e73c7e');
          root.style.setProperty('--accent', '#23a6d5');
          root.style.setProperty('--sent-bg', 'linear-gradient(135deg, #e73c7e 0%, #23a6d5 100%)');
          break;
        default:
          // Reset to default values
          root.style.setProperty('--bg-dark', '#0a0e1a');
          root.style.setProperty('--bg-card', '#1a1f2e');
          root.style.setProperty('--accent', '#00d4ff');
          root.style.setProperty('--text-primary', '#f8fafc');
          root.style.setProperty('--text-secondary', '#cbd5e1');
          root.style.setProperty('--sent-bg', 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)');
      }
    }

    function applySettings(settings) {
      // Apply message animations
      const messagesContainer = document.getElementById('messages');
      if (settings.messageAnimations) {
        messagesContainer.classList.add('animated');
      } else {
        messagesContainer.classList.remove('animated');
      }
      
      // Apply compact mode
      if (settings.compactMode) {
        document.body.classList.add('compact-mode');
      } else {
        document.body.classList.remove('compact-mode');
      }
      
      // Apply timestamps visibility
      const timestamps = document.querySelectorAll('.timestamp');
      timestamps.forEach(ts => {
        ts.style.display = settings.showTimestamps ? 'block' : 'none';
      });
    }

    function loadSavedSettings() {
      const savedSettings = localStorage.getItem('appSettings');
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        
        // Restore theme
        const themeOption = document.querySelector(`[data-theme="${settings.theme}"]`);
        if (themeOption) {
          document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
          themeOption.classList.add('active');
          applyTheme(settings.theme);
        }
        
        // Restore checkboxes
        Object.keys(settings).forEach(key => {
          const element = document.getElementById(key);
          if (element && element.type === 'checkbox') {
            element.checked = settings[key];
          }
        });
        
        // Apply settings
        applySettings(settings);
      }
    }

    // Load saved theme on startup
    function loadSavedTheme() {
      const savedTheme = localStorage.getItem('selectedTheme');
      if (savedTheme) {
        const themeOption = document.querySelector(`.bg-option[data-bg="${savedTheme}"]`);
        if (themeOption) {
          document.querySelectorAll('.bg-option').forEach(opt => opt.classList.remove('active'));
          themeOption.classList.add('active');
          saveSettings(); // Apply the saved theme
        }
      }
    }

    // Handle profile picture upload
    function handleProfilePictureUpload() {
      const file = profilePictureUpload.files[0];
      if (!file) return;

      // Validate file type
      if (!file.type.match('image.*')) {
        showStatus(settingsStatus, 'Only images are allowed', 'error');
        profilePictureUpload.value = '';
        return;
      }

      // Validate file size (max 5MB)
      if (file.size > 5 * 1024 * 1024) {
        showStatus(settingsStatus, 'Image must be smaller than 5MB', 'error');
        profilePictureUpload.value = '';
        return;
      }

      profilePictureFile = file;
      
      // Show preview
      const reader = new FileReader();
      reader.onload = function(e) {
        profileAvatarImg.src = e.target.result;
        profileAvatarImg.style.display = 'block';
        profileAvatarText.style.display = 'none';
      };
      reader.readAsDataURL(file);
    }

    // Save profile changes
    async function saveProfile() {
      showStatus(settingsStatus, 'Saving profile...', 'loading');
      saveProfileBtn.disabled = true;

      try {
        const updates = {
          'profile/description': profileDescriptionInput.value
        };

        if (profilePictureFile) {
          // Upload new profile picture
          const formData = new FormData();
          formData.append("image", profilePictureFile);
          
          const res = await fetch("https://api.imgbb.com/1/upload?key=2d802312c23a6e0a1586772e069f1767", {
            method: "POST",
            body: formData
          });
          
          const data = await res.json();
          
          if (!data.success) {
            throw new Error(data.error.message || 'Profile picture upload failed');
          }
          
          updates['profile/avatarUrl'] = data.data.url;
        }

        // Update profile in database
        await db.ref(`users/${currentUser.username}`).update(updates);

        // Update local user data
        currentUser.profile.description = profileDescriptionInput.value;
        if (profilePictureFile) {
          currentUser.profile.avatarUrl = updates['profile/avatarUrl'];
        }

        // Update UI
        profileDescription.textContent = profileDescriptionInput.value;
        if (profilePictureFile) {
          profileAvatarImg.src = currentUser.profile.avatarUrl;
          profileAvatarImg.style.display = 'block';
          profileAvatarText.style.display = 'none';
        }

        showStatus(settingsStatus, 'Profile saved!', 'success');
        
        // Switch back to view mode
        profileView.style.display = 'flex';
        profileEditForm.style.display = 'none';
        profilePictureFile = null;
        profilePictureUpload.value = '';
      } catch (error) {
        console.error('Profile save error:', error);
        showStatus(settingsStatus, `Error: ${error.message}`, 'error');
      } finally {
        saveProfileBtn.disabled = false;
      }
    }

    // View user profile
    async function viewUserProfile(username) {
      try {
        // If viewing own profile, show edit form
        if (username === currentUser.username) {
          profileView.style.display = 'none';
          profileEditForm.style.display = 'flex';
          profileDescriptionInput.value = currentUser.profile.description || '';
          return;
        }

        // Otherwise show profile modal
        const snapshot = await db.ref(`users/${username}`).once('value');
        const user = snapshot.val();
        
        if (!user) {
          throw new Error('User not found');
        }

        currentlyViewingProfile = username;
        profileModalTitle.textContent = `${username}'s Profile`;
        profileModalName.textContent = username;
        profileModalDescription.textContent = user.profile?.description || 'No description yet';
        
        // Set avatar
        profileModalAvatarText.textContent = username.charAt(0).toUpperCase();
        if (user.profile?.avatarUrl) {
          profileModalAvatarImg.src = user.profile.avatarUrl;
          profileModalAvatarImg.style.display = 'block';
          profileModalAvatarText.style.display = 'none';
        } else {
          profileModalAvatarImg.style.display = 'none';
          profileModalAvatarText.style.display = 'block';
        }

        // Show/hide block button based on current status
        if (currentUser.blockedUsers.includes(username)) {
          blockUserBtn.innerHTML = '<i class="fas fa-user-check"></i><span>Unblock User</span>';
          blockUserBtn.style.background = 'var(--success)';
        } else {
          blockUserBtn.innerHTML = '<i class="fas fa-ban"></i><span>Block User</span>';
          blockUserBtn.style.background = 'var(--error)';
        }

        profileViewModal.classList.add('active');
      } catch (error) {
        console.error('Error viewing profile:', error);
        showStatus(chatStatus, `Error: ${error.message}`, 'error');
      }
    }

    // Block or unblock a user
    async function blockUser(username = currentlyViewingProfile) {
      if (!username) return;
      
      try {
        const isBlocked = currentUser.blockedUsers.includes(username);
        
        if (isBlocked) {
          // Unblock user
          await db.ref(`users/${currentUser.username}/blockedUsers`).transaction((blockedUsers) => {
            blockedUsers = blockedUsers || [];
            return blockedUsers.filter(u => u !== username);
          });
          
          currentUser.blockedUsers = currentUser.blockedUsers.filter(u => u !== username);
          showStatus(chatStatus, `Unblocked ${username}`, 'success');
        } else {
          // Block user
          await db.ref(`users/${currentUser.username}/blockedUsers`).transaction((blockedUsers) => {
            blockedUsers = blockedUsers || [];
            if (!blockedUsers.includes(username)) {
              blockedUsers.push(username);
            }
            return blockedUsers;
          });
          
          // Remove from friends if they were friends
          if (currentUser.friends.includes(username)) {
            await db.ref(`users/${currentUser.username}/friends`).transaction((friends) => {
              friends = friends || [];
              return friends.filter(f => f !== username);
            });
            
            // Also remove from the other user's friends list
            await db.ref(`users/${username}/friends`).transaction((friends) => {
              friends = friends || [];
              return friends.filter(f => f !== currentUser.username);
            });
            
            currentUser.friends = currentUser.friends.filter(f => f !== username);
          }
          
          // Remove any pending requests
          await db.ref(`users/${currentUser.username}/friendRequests`).transaction((requests) => {
            requests = requests || [];
            return requests.filter(r => r !== username);
          });
          
          await db.ref(`users/${username}/friendRequests`).transaction((requests) => {
            requests = requests || [];
            return requests.filter(r => r !== currentUser.username);
          });
          
          currentUser.blockedUsers.push(username);
          showStatus(chatStatus, `Blocked ${username}`, 'success');
        }
        
        // Reload data
        loadFriends();
        loadFriendRequests();
        
        // Update UI if viewing profile
        if (currentlyViewingProfile === username) {
          if (isBlocked) {
            blockUserBtn.innerHTML = '<i class="fas fa-ban"></i><span>Block User</span>';
            blockUserBtn.style.background = 'var(--error)';
          } else {
            blockUserBtn.innerHTML = '<i class="fas fa-user-check"></i><span>Unblock User</span>';
            blockUserBtn.style.background = 'var(--success)';
          }
        }
        
        // Close chat if currently chatting with blocked user
        if (currentChat && currentChat.type === 'friend' && currentChat.id === username) {
          currentChat = null;
          messagesContainer.innerHTML = '';
          chatTitle.textContent = 'Direct Messages';
        }
      } catch (error) {
        console.error('Error blocking/unblocking user:', error);
        showStatus(chatStatus, `Error: ${error.message}`, 'error');
      }
    }

    // Load blocked users
    async function loadBlockedUsers() {
      try {
        blockedUsersList.innerHTML = '';
        
        for (const username of currentUser.blockedUsers) {
          const blockedUserItem = document.createElement('div');
          blockedUserItem.className = 'blocked-user-item';
          blockedUserItem.innerHTML = `
            <div>${username}</div>
            <button class="unblock-user" data-username="${username}" style="background: var(--success);">
              <i class="fas fa-user-check"></i> Unblock
            </button>
          `;
          
          blockedUsersList.appendChild(blockedUserItem);
        }
        
        // Add event listeners to unblock buttons
        document.querySelectorAll('.unblock-user').forEach(btn => {
          btn.addEventListener('click', () => blockUser(btn.dataset.username));
        });
      } catch (error) {
        console.error('Error loading blocked users:', error);
        showStatus(blockedUsersStatus, `Error: ${error.message}`, 'error');
      }
    }

    // Test function to add a sample message (for debugging)
    function addTestMessage() {
      if (!currentChat) {
        showStatus(chatStatus, 'Open a chat first', 'error');
        return;
      }
      
      const chatId = getChatId(currentChat.id, currentChat.type);
      db.ref(`messages/${currentChat.type}/${chatId}`).push({
        type: "text",
        text: maybeEncrypt("This is a test message from " + currentUser.username),
        time: Date.now(),
        username: currentUser.username,
        userId: currentUser.username,
        edited: false
      });
    }

    // Debug function to test features
    function debugFeatures() {
      console.log('=== DEBUG INFO ===');
      console.log('Current user:', currentUser);
      console.log('Current chat:', currentChat);
      console.log('AI Memory:', aiMemory);
      console.log('Selected theme:', localStorage.getItem('selectedTheme'));
      console.log('Hidden chats:', hiddenChats);
      console.log('==================');
      
      showStatus(chatStatus, 'Debug info logged to console', 'info');
    }

    // Initialize the app
    init();
  </script>
</body>
</html>
