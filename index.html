<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Call (No Camera Needed)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      text-align: center;
    }
    button {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:disabled {
      background: #ccc;
    }
    input {
      padding: 10px;
      width: 200px;
      margin: 10px;
    }
    #status {
      margin: 20px 0;
      font-weight: bold;
      min-height: 24px;
    }
    #user-list {
      margin: 20px 0;
      text-align: left;
    }
    .user-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }
    .user-item:hover {
      background: #f5f5f5;
    }
    #chat-box {
      height: 200px;
      border: 1px solid #ddd;
      overflow-y: scroll;
      text-align: left;
      padding: 10px;
      margin: 10px 0;
    }
    #message-input {
      width: 70%;
    }
  </style>
</head>
<body>
  <h1>Web Call (Data Channel)</h1>
  
  <div id="login-section">
    <input type="text" id="username" placeholder="Your Name" />
    <button id="login-btn">Login</button>
  </div>

  <div id="call-section" style="display: none;">
    <div id="user-list">
      <h3>Online Users:</h3>
      <!-- Users will appear here -->
    </div>
    
    <div id="active-call-ui" style="display: none;">
      <div id="status">Status: Connected to <span id="connected-user"></span></div>
      <div id="chat-box"></div>
      <input type="text" id="message-input" placeholder="Type a message" />
      <button id="send-message-btn">Send</button>
      <button id="end-call-btn">End Connection</button>
    </div>
    
    <div id="call-controls">
      <button id="start-call-btn" disabled>Connect</button>
    </div>
  </div>

  <!-- Firebase for signaling -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  
  <script>
    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyD9uzP781-TlDSC9fILQX8M-Xa7Ely_rZc",
      authDomain: "chayt-41951.firebaseapp.com",
      databaseURL: "https://chayt-41951-default-rtdb.firebaseio.com",
      projectId: "chayt-41951",
      storageBucket: "chayt-41951.appspot.com",
      messagingSenderId: "841659925542",
      appId: "1:841659925542:web:ba7751ee2a97b5fcf452e7"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    // DOM Elements
    const loginBtn = document.getElementById('login-btn');
    const startCallBtn = document.getElementById('start-call-btn');
    const endCallBtn = document.getElementById('end-call-btn');
    const sendMessageBtn = document.getElementById('send-message-btn');
    const messageInput = document.getElementById('message-input');
    const usernameInput = document.getElementById('username');
    const statusDisplay = document.getElementById('status');
    const connectedUserSpan = document.getElementById('connected-user');
    const loginSection = document.getElementById('login-section');
    const callSection = document.getElementById('call-section');
    const activeCallUI = document.getElementById('active-call-ui');
    const userList = document.getElementById('user-list');
    const callControls = document.getElementById('call-controls');
    const chatBox = document.getElementById('chat-box');

    // WebRTC Variables
    let peerConnection;
    let dataChannel;
    let currentUser;
    let targetUser;
    let onlineUsers = {};
    let userRef;
    let callsRef;
    let isProcessingOffer = false;

    // Login Function
    loginBtn.addEventListener('click', async () => {
      currentUser = usernameInput.value.trim();
      if (!currentUser) return;

      // Set up user presence
      userRef = database.ref(`users/${currentUser}`);
      callsRef = database.ref(`calls/${currentUser}`);
      
      // Mark user as online
      userRef.set({
        online: true,
        lastSeen: firebase.database.ServerValue.TIMESTAMP
      });
      
      // Remove user when they disconnect
      userRef.onDisconnect().remove();
      
      // Show call UI
      loginSection.style.display = 'none';
      callSection.style.display = 'block';
      statusDisplay.textContent = `Logged in as: ${currentUser}`;
      
      // Listen for online users
      database.ref('users').on('value', (snapshot) => {
        onlineUsers = snapshot.val() || {};
        updateUserList();
      });
      
      // Listen for incoming connections
      setupConnectionListeners();
    });

    // Update list of online users
    function updateUserList() {
      userList.innerHTML = '<h3>Online Users:</h3>';
      
      Object.keys(onlineUsers).forEach(username => {
        if (username !== currentUser) {
          const userItem = document.createElement('div');
          userItem.className = 'user-item';
          userItem.textContent = username;
          userItem.dataset.username = username;
          userItem.addEventListener('click', () => selectUser(username));
          userList.appendChild(userItem);
        }
      });
      
      if (Object.keys(onlineUsers).length <= 1) {
        userList.innerHTML += '<div>No other users online</div>';
      }
    }

    // Select a user to connect to
    function selectUser(username) {
      // Highlight selected user
      document.querySelectorAll('.user-item').forEach(item => {
        item.style.backgroundColor = item.dataset.username === username ? '#e0f7fa' : '';
      });
      
      targetUser = username;
      startCallBtn.disabled = false;
    }

    // Start Connection Function
    startCallBtn.addEventListener('click', async () => {
      if (!targetUser) return;
      
      statusDisplay.textContent = `Connecting to ${targetUser}...`;
      startCallBtn.disabled = true;
      
      // Create peer connection
      peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" }
        ]
      });

      // Create data channel
      dataChannel = peerConnection.createDataChannel("chat");
      setupDataChannelListeners(dataChannel);

      // Listen for ICE candidates (network info)
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          database.ref(`calls/${targetUser}/candidates`).push({
            sender: currentUser,
            candidate: event.candidate
          });
        }
      };

      // Create offer (connection request)
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      // Send offer to target user
      database.ref(`calls/${targetUser}`).set({
        type: 'offer',
        sender: currentUser,
        offer: offer
      });

      // Set timeout if no answer
      setTimeout(() => {
        if (!dataChannel || dataChannel.readyState !== 'open') {
          statusDisplay.textContent = `${targetUser} is not responding`;
          cleanupConnection();
        }
      }, 30000);
    });

    // Setup data channel listeners
    function setupDataChannelListeners(channel) {
      channel.onopen = () => {
        statusDisplay.textContent = `Connected to ${targetUser}`;
        connectedUserSpan.textContent = targetUser;
        activeCallUI.style.display = 'block';
        callControls.style.display = 'none';
        messageInput.disabled = false;
        sendMessageBtn.disabled = false;
        messageInput.focus();
      };
      
      channel.onclose = () => {
        addMessage("Connection closed", "system");
        cleanupConnection();
      };
      
      channel.onmessage = (event) => {
        addMessage(event.data, "remote");
      };
    }

    // Setup connection listeners for incoming connections
    function setupConnectionListeners() {
      // Listen for offers
      callsRef.on('value', async (snapshot) => {
        const data = snapshot.val();
        if (!data || !data.type || isProcessingOffer) return;
        
        if (data.type === 'offer' && data.sender && data.sender !== currentUser) {
          isProcessingOffer = true;
          targetUser = data.sender;
          
          // Confirm connection
          if (confirm(`Incoming connection from ${targetUser}. Accept?`)) {
            // Create peer connection
            peerConnection = new RTCPeerConnection({
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" }
              ]
            });

            // Listen for data channel
            peerConnection.ondatachannel = (event) => {
              dataChannel = event.channel;
              setupDataChannelListeners(dataChannel);
            };

            // Listen for ICE candidates
            peerConnection.onicecandidate = (event) => {
              if (event.candidate) {
                database.ref(`calls/${targetUser}/candidates`).push({
                  sender: currentUser,
                  candidate: event.candidate
                });
              }
            };

            // Set remote offer
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));

            // Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            // Send answer
            database.ref(`calls/${targetUser}`).set({
              type: 'answer',
              sender: currentUser,
              answer: answer
            });
            
            // Clear the offer data to prevent reprocessing
            database.ref(`calls/${currentUser}`).update({
              type: null,
              offer: null,
              sender: null
            });
          } else {
            // Reject connection
            database.ref(`calls/${targetUser}`).set({
              type: 'reject',
              sender: currentUser
            });
            
            // Clear the offer data
            database.ref(`calls/${currentUser}`).remove();
          }
          isProcessingOffer = false;
        }
        
        // Listen for answer
        if (data.type === 'answer' && data.sender === targetUser) {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
        
        // Listen for rejection
        if (data.type === 'reject' && data.sender === targetUser) {
          statusDisplay.textContent = `${targetUser} declined your connection`;
          cleanupConnection();
        }
      });

      // Listen for ICE candidates from peer
      callsRef.child('candidates').on('child_added', async (snapshot) => {
        const data = snapshot.val();
        if (data && data.sender === targetUser && peerConnection) {
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
          } catch (e) {
            console.error('Error adding ICE candidate:', e);
          }
        }
      });
    }

    // Send message through data channel
    sendMessageBtn.addEventListener('click', sendMessage);
    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    function sendMessage() {
      const message = messageInput.value.trim();
      if (!message || !dataChannel || dataChannel.readyState !== 'open') return;
      
      dataChannel.send(message);
      addMessage(message, "local");
      messageInput.value = '';
    }

    // Add message to chat box
    function addMessage(message, type) {
      const messageDiv = document.createElement('div');
      messageDiv.style.margin = '5px 0';
      messageDiv.style.padding = '5px';
      messageDiv.style.borderRadius = '5px';
      
      if (type === "local") {
        messageDiv.style.textAlign = 'right';
        messageDiv.style.backgroundColor = '#e3f2fd';
        messageDiv.textContent = `You: ${message}`;
      } else if (type === "remote") {
        messageDiv.style.textAlign = 'left';
        messageDiv.style.backgroundColor = '#f1f1f1';
        messageDiv.textContent = `${targetUser}: ${message}`;
      } else {
        messageDiv.style.textAlign = 'center';
        messageDiv.style.color = '#666';
        messageDiv.style.fontStyle = 'italic';
        messageDiv.textContent = message;
      }
      
      chatBox.appendChild(messageDiv);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // End Connection Function
    endCallBtn.addEventListener('click', () => {
      cleanupConnection();
      statusDisplay.textContent = `Disconnected from ${targetUser}`;
      addMessage("Connection ended", "system");
    });

    // Clean up connection resources
    function cleanupConnection() {
      if (dataChannel) {
        dataChannel.close();
        dataChannel = null;
      }
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      activeCallUI.style.display = 'none';
      callControls.style.display = 'block';
      startCallBtn.disabled = true;
      messageInput.disabled = true;
      sendMessageBtn.disabled = true;
      targetUser = null;
      isProcessingOffer = false;
      
      // Clear connection data
      if (targetUser) {
        database.ref(`calls/${targetUser}`).remove();
      }
      database.ref(`calls/${currentUser}`).remove();
      
      // Clear user selection
      document.querySelectorAll('.user-item').forEach(item => {
        item.style.backgroundColor = '';
      });
    }

    // Clean up when leaving
    window.addEventListener('beforeunload', () => {
      cleanupConnection();
      if (userRef) userRef.remove();
    });
  </script>
</body>
</html>
